using System.Globalization;
using System.Text;
using Boutique.Models;
using Boutique.ViewModels;

namespace Boutique.Utilities;

/// <summary>
/// Central formatter for distribution file content.
/// This is the single source of truth for SPID and SkyPatcher file format generation.
/// </summary>
public static class DistributionFileFormatter
{
    /// <summary>
    /// Generates the complete file content for a distribution file.
    /// </summary>
    public static string GenerateFileContent(
        IEnumerable<DistributionEntryViewModel> entries,
        DistributionFileType format,
        IReadOnlyList<DistributionParseError>? unparsedLines = null)
    {
        var lines = new List<string>
        {
            "; Distribution File",
            "; Generated by Boutique",
            string.Empty
        };

        foreach (var entry in entries)
        {
            string? line = null;

            if (entry.Entry.OriginalSpidFilter != null && format == DistributionFileType.Spid)
            {
                line = FormatSpidDistributionFilter(entry.Entry.OriginalSpidFilter);
            }
            else if (entry.Type == DistributionType.Keyword)
            {
                if (!string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
                {
                    line = FormatSpidKeywordLine(entry);
                }
            }
            else if (entry.SelectedOutfit != null)
            {
                line = format == DistributionFileType.Spid
                    ? FormatSpidLine(entry)
                    : FormatSkyPatcherLine(entry);
            }

            if (line != null)
            {
                lines.Add(line);
            }
        }

        if (unparsedLines is not { Count: > 0 }) return string.Join(Environment.NewLine, lines);

        var spidPreserved = unparsedLines.Where(e => e.Reason.EndsWith("(preserved)", StringComparison.Ordinal) && e.Reason.Contains("SPID", StringComparison.OrdinalIgnoreCase)).ToList();
        var skyPatcherPreserved = unparsedLines.Where(e => e.Reason.EndsWith("(preserved)", StringComparison.Ordinal) && e.Reason.Contains("SkyPatcher", StringComparison.OrdinalIgnoreCase)).ToList();
        var errorLines = unparsedLines.Where(e => !e.Reason.EndsWith("(preserved)", StringComparison.Ordinal)).ToList();

        if (spidPreserved.Count > 0)
        {
            lines.Add(string.Empty);
            lines.Add("; Other SPID distributions (preserved from original file)");
            lines.AddRange(spidPreserved.Select(preserved => preserved.LineContent));
        }

        if (skyPatcherPreserved.Count > 0)
        {
            lines.Add(string.Empty);
            lines.Add("; SkyPatcher distributions with unresolved filters (preserved from original file)");
            lines.AddRange(skyPatcherPreserved.Select(preserved => preserved.LineContent));
        }

        if (errorLines.Count <= 0) return string.Join(Environment.NewLine, lines);

        lines.Add(string.Empty);
        lines.Add("; Lines that Boutique could not parse (preserved from original file)");
        lines.AddRange(errorLines.Select(error => error.LineContent));

        return string.Join(Environment.NewLine, lines);
    }

    /// <summary>
    /// Formats a single entry as a SPID distribution line.
    /// Format: Outfit = FormID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));

        // Position 1: Outfit identifier
        var outfitIdentifier = FormKeyHelper.FormatForSpid(entry.SelectedOutfit.FormKey);

        // Position 2: StringFilters - NPC names (comma-separated) and Keywords (+ for AND)
        var stringFilterParts = new List<string>();

        // NPC names (comma-separated for OR)
        var npcNames = entry.SelectedNpcs
            .Where(npc => !string.IsNullOrWhiteSpace(npc.DisplayName))
            .Select(npc => npc.DisplayName)
            .ToList();
        if (npcNames.Count > 0)
        {
            stringFilterParts.Add(string.Join(",", npcNames));
        }

        // Included keywords (+ separated for AND)
        var includedKeywords = entry.SelectedKeywords
            .Where(k => !k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => k.EditorID)
            .ToList();
        if (includedKeywords.Count > 0)
        {
            stringFilterParts.Add(string.Join("+", includedKeywords));
        }

        // Excluded keywords (comma-separated as global exclusions)
        var excludedKeywords = entry.SelectedKeywords
            .Where(k => k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => $"-{k.EditorID}")
            .ToList();
        stringFilterParts.AddRange(excludedKeywords);

        // Add raw string filters
        if (!string.IsNullOrWhiteSpace(entry.RawStringFilters))
        {
            stringFilterParts.Add(entry.RawStringFilters.Trim());
        }

        var stringFiltersPart = stringFilterParts.Count > 0 ? string.Join(",", stringFilterParts) : null;

        // Position 3: FormFilters - Factions, Races, Classes (+ for AND)
        var formFilterParts = new List<string>();
        var formExclusions = new List<string>();

        foreach (var faction in entry.SelectedFactions)
        {
            var editorId = faction.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                if (faction.IsExcluded)
                    formExclusions.Add($"-{editorId}");
                else
                    formFilterParts.Add(editorId);
            }
        }

        foreach (var race in entry.SelectedRaces)
        {
            var editorId = race.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                if (race.IsExcluded)
                    formExclusions.Add($"-{editorId}");
                else
                    formFilterParts.Add(editorId);
            }
        }

        foreach (var classVm in entry.SelectedClasses)
        {
            var editorId = classVm.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilterParts.Add(editorId);
            }
        }

        // Combine included parts with + and append exclusions
        var formFilterResult = new List<string>();
        if (formFilterParts.Count > 0)
            formFilterResult.Add(string.Join("+", formFilterParts));
        formFilterResult.AddRange(formExclusions);

        // Add raw form filters
        if (!string.IsNullOrWhiteSpace(entry.RawFormFilters))
        {
            formFilterResult.Add(entry.RawFormFilters.Trim());
        }

        var formFiltersPart = formFilterResult.Count > 0 ? string.Join(",", formFilterResult) : null;

        // Position 4: LevelFilters (skill filters like "12(85/999)")
        var levelFiltersPart = !string.IsNullOrWhiteSpace(entry.LevelFilters) ? entry.LevelFilters : null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.Entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.UseChance && entry.Chance != 100
            ? entry.Chance.ToString(CultureInfo.InvariantCulture)
            : null;

        // Build the line, preserving intermediate NONEs but trimming trailing ones
        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        // Find the last non-null position
        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        // Build the SPID line
        var sb = new StringBuilder();
        sb.Append("Outfit = ");
        sb.Append(outfitIdentifier);

        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a single entry as a SPID keyword distribution line.
    /// Format: Keyword = EditorID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidKeywordLine(DistributionEntryViewModel entry)
    {
        if (string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
            throw new ArgumentException("Entry must have a keyword to distribute", nameof(entry));

        // Position 1: Keyword EditorID
        var keywordIdentifier = entry.KeywordToDistribute;

        // Position 2: StringFilters - NPC names (comma-separated) and Keywords (+ for AND)
        var stringFilterParts = new List<string>();

        var npcNames = entry.SelectedNpcs
            .Where(npc => !string.IsNullOrWhiteSpace(npc.DisplayName))
            .Select(npc => npc.DisplayName)
            .ToList();
        if (npcNames.Count > 0)
        {
            stringFilterParts.Add(string.Join(",", npcNames));
        }

        // Included keywords (+ separated for AND)
        var includedKeywords = entry.SelectedKeywords
            .Where(k => !k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => k.EditorID)
            .ToList();
        if (includedKeywords.Count > 0)
        {
            stringFilterParts.Add(string.Join("+", includedKeywords));
        }

        // Excluded keywords (comma-separated as global exclusions)
        var excludedKeywords = entry.SelectedKeywords
            .Where(k => k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => $"-{k.EditorID}")
            .ToList();
        stringFilterParts.AddRange(excludedKeywords);

        // Add raw string filters
        if (!string.IsNullOrWhiteSpace(entry.RawStringFilters))
        {
            stringFilterParts.Add(entry.RawStringFilters.Trim());
        }

        var stringFiltersPart = stringFilterParts.Count > 0 ? string.Join(",", stringFilterParts) : null;

        // Position 3: FormFilters - Factions, Races, Classes (+ for AND)
        var formFilterParts = new List<string>();
        var formExclusions = new List<string>();

        foreach (var faction in entry.SelectedFactions)
        {
            var editorId = faction.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                if (faction.IsExcluded)
                    formExclusions.Add($"-{editorId}");
                else
                    formFilterParts.Add(editorId);
            }
        }

        foreach (var race in entry.SelectedRaces)
        {
            var editorId = race.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                if (race.IsExcluded)
                    formExclusions.Add($"-{editorId}");
                else
                    formFilterParts.Add(editorId);
            }
        }

        foreach (var classVm in entry.SelectedClasses)
        {
            var editorId = classVm.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilterParts.Add(editorId);
            }
        }

        // Combine included parts with + and append exclusions
        var formFilterResult = new List<string>();
        if (formFilterParts.Count > 0)
            formFilterResult.Add(string.Join("+", formFilterParts));
        formFilterResult.AddRange(formExclusions);

        // Add raw form filters
        if (!string.IsNullOrWhiteSpace(entry.RawFormFilters))
        {
            formFilterResult.Add(entry.RawFormFilters.Trim());
        }

        var formFiltersPart = formFilterResult.Count > 0 ? string.Join(",", formFilterResult) : null;

        // Position 4: LevelFilters (skill filters like "12(85/999)")
        var levelFiltersPart = !string.IsNullOrWhiteSpace(entry.LevelFilters) ? entry.LevelFilters : null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.Entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.UseChance && entry.Chance != 100
            ? entry.Chance.ToString(CultureInfo.InvariantCulture)
            : null;

        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        var sb = new StringBuilder();
        sb.Append("Keyword = ");
        sb.Append(keywordIdentifier);

        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a single entry as a SkyPatcher distribution line.
    /// Format: filterByX=value:filterByY=value:outfitDefault=FormKey
    /// </summary>
    public static string FormatSkyPatcherLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));

        var filterParts = new List<string>();

        if (entry.SelectedNpcs.Count > 0)
        {
            var npcFormKeys = entry.SelectedNpcs
                .Select(npc => FormKeyHelper.Format(npc.FormKey))
                .ToList();
            var npcList = string.Join(",", npcFormKeys);
            filterParts.Add($"filterByNpcs={npcList}");
        }

        if (entry.SelectedFactions.Count > 0)
        {
            var factionFormKeys = entry.SelectedFactions
                .Select(faction => FormKeyHelper.Format(faction.FormKey))
                .ToList();
            var factionList = string.Join(",", factionFormKeys);
            filterParts.Add($"filterByFactions={factionList}");
        }

        if (entry.SelectedKeywords.Count > 0)
        {
            var keywordFormKeys = entry.SelectedKeywords
                .Select(keyword => FormKeyHelper.Format(keyword.FormKey))
                .ToList();
            var keywordList = string.Join(",", keywordFormKeys);
            filterParts.Add($"filterByKeywords={keywordList}");
        }

        if (entry.SelectedRaces.Count > 0)
        {
            var raceFormKeys = entry.SelectedRaces
                .Select(race => FormKeyHelper.Format(race.FormKey))
                .ToList();
            var raceList = string.Join(",", raceFormKeys);
            filterParts.Add($"filterByRaces={raceList}");
        }

        if (entry.SelectedClasses.Count > 0)
        {
            var classFormKeys = entry.SelectedClasses
                .Select(c => FormKeyHelper.Format(c.FormKey))
                .ToList();
            var classList = string.Join(",", classFormKeys);
            filterParts.Add($"filterByClass={classList}");
        }

        if (entry.Gender != GenderFilter.Any)
        {
            var genderValue = entry.Gender == GenderFilter.Female ? "female" : "male";
            filterParts.Add($"filterByGender={genderValue}");
        }

        var outfitFormKey = FormKeyHelper.Format(entry.SelectedOutfit.FormKey);
        filterParts.Add($"outfitDefault={outfitFormKey}");

        return string.Join(":", filterParts);
    }

    /// <summary>
    /// Formats a parsed SpidDistributionFilter back to SPID syntax.
    /// This enables round-trip testing of parsing/formatting.
    /// </summary>
    public static string FormatSpidDistributionFilter(SpidDistributionFilter filter)
    {
        var formTypeKeyword = filter.FormType switch
        {
            SpidFormType.Outfit => "Outfit",
            SpidFormType.Keyword => "Keyword",
            SpidFormType.Spell => "Spell",
            SpidFormType.Perk => "Perk",
            SpidFormType.Item => "Item",
            SpidFormType.Shout => "Shout",
            SpidFormType.Package => "Package",
            SpidFormType.Faction => "Faction",
            SpidFormType.SleepOutfit => "SleepOutfit",
            SpidFormType.Skin => "Skin",
            _ => "Outfit"
        };

        var stringFiltersPart = FormatFilterSection(filter.StringFilters);
        var formFiltersPart = FormatFilterSection(filter.FormFilters);
        var levelFiltersPart = filter.LevelFilters;
        var traitFiltersPart = FormatTraitFilters(filter.TraitFilters);
        var countPart = filter.CountOrPackageIdx;
        var chancePart = filter.Chance != 100 ? filter.Chance.ToString(CultureInfo.InvariantCulture) : null;

        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        // Find the last non-null value
        var lastOutputIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastOutputIndex = i;
                break;
            }
        }

        var sb = new StringBuilder();
        sb.Append(formTypeKeyword);
        sb.Append(" = ");
        sb.Append(filter.FormIdentifier);

        for (var i = 0; i <= lastOutputIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a SpidFilterSection back to SPID syntax.
    /// Uses + for AND (within expression), , for OR (between expressions), and , for global exclusions.
    /// </summary>
    public static string? FormatFilterSection(SpidFilterSection section)
    {
        if (section.IsEmpty)
            return null;

        var result = new List<string>();

        foreach (var expr in section.Expressions)
        {
            if (expr.Parts.Count == 0)
                continue;

            var parts = expr.Parts.Select(part =>
            {
                var prefix = part.IsNegated ? "-" : string.Empty;
                return $"{prefix}{part.Value}";
            });

            result.Add(string.Join("+", parts));
        }

        foreach (var exclusion in section.GlobalExclusions)
        {
            result.Add($"-{exclusion.Value}");
        }

        return result.Count > 0 ? string.Join(",", result) : null;
    }

    /// <summary>
    /// Formats SPID trait filters (Position 5).
    /// </summary>
    public static string? FormatTraitFilters(SpidTraitFilters traits)
    {
        if (traits.IsEmpty)
            return null;

        var parts = new List<string>();

        if (traits.IsFemale == true)
            parts.Add("F");
        else if (traits.IsFemale == false)
            parts.Add("M");

        if (traits.IsUnique == true)
            parts.Add("U");
        else if (traits.IsUnique == false)
            parts.Add("-U");

        if (traits.IsSummonable == true)
            parts.Add("S");
        else if (traits.IsSummonable == false)
            parts.Add("-S");

        if (traits.IsChild == true)
            parts.Add("C");
        else if (traits.IsChild == false)
            parts.Add("-C");

        if (traits.IsLeveled == true)
            parts.Add("L");
        else if (traits.IsLeveled == false)
            parts.Add("-L");

        if (traits.IsTeammate == true)
            parts.Add("T");
        else if (traits.IsTeammate == false)
            parts.Add("-T");

        if (traits.IsDead == true)
            parts.Add("D");
        else if (traits.IsDead == false)
            parts.Add("-D");

        return parts.Count > 0 ? string.Join("/", parts) : null;
    }
}
