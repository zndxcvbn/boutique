using System.Globalization;
using System.Text;
using Boutique.Models;
using Boutique.ViewModels;

namespace Boutique.Utilities;

/// <summary>
/// Central formatter for distribution file content.
/// This is the single source of truth for SPID and SkyPatcher file format generation.
/// </summary>
public static class DistributionFileFormatter
{
    /// <summary>
    /// Generates the complete file content for a distribution file.
    /// </summary>
    public static string GenerateFileContent(
        IEnumerable<DistributionEntryViewModel> entries,
        DistributionFileType format,
        IReadOnlyList<DistributionParseError>? unparsedLines = null)
    {
        var lines = new List<string>
        {
            "; Distribution File",
            "; Generated by Boutique",
            ""
        };

        foreach (var entry in entries)
        {
            string? line = null;

            if (entry.Type == DistributionType.Keyword)
            {
                if (!string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
                {
                    line = FormatSpidKeywordLine(entry);
                }
            }
            else if (entry.SelectedOutfit != null)
            {
                line = format == DistributionFileType.Spid
                    ? FormatSpidLine(entry)
                    : FormatSkyPatcherLine(entry);
            }

            if (line != null)
            {
                lines.Add(line);
            }
        }

        if (unparsedLines != null && unparsedLines.Count > 0)
        {
            // Separate preserved lines (other SPID types like Spell, Perk, etc.) from actual parse errors
            var preservedLines = unparsedLines.Where(e => e.Reason.EndsWith("(preserved)", StringComparison.Ordinal)).ToList();
            var errorLines = unparsedLines.Where(e => !e.Reason.EndsWith("(preserved)", StringComparison.Ordinal)).ToList();

            // Add preserved lines first (other SPID distribution types)
            if (preservedLines.Count > 0)
            {
                lines.Add("");
                lines.Add("; Other SPID distributions (preserved from original file)");
                foreach (var preserved in preservedLines)
                {
                    lines.Add(preserved.LineContent);
                }
            }

            // Add actual parse errors
            if (errorLines.Count > 0)
            {
                lines.Add("");
                lines.Add("; Lines that Boutique could not parse (preserved from original file)");
                foreach (var error in errorLines)
                {
                    lines.Add(error.LineContent);
                }
            }
        }

        return string.Join(Environment.NewLine, lines);
    }

    /// <summary>
    /// Formats a single entry as a SPID distribution line.
    /// Format: Outfit = FormID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));

        // Position 1: Outfit identifier
        var outfitIdentifier = FormKeyHelper.FormatForSpid(entry.SelectedOutfit.FormKey);

        // Position 2: StringFilters - NPC names (comma-separated) and Keywords (+ for AND)
        var stringFilters = new List<string>();

        // NPC names (comma-separated for OR)
        var npcNames = entry.SelectedNpcs
            .Where(npc => !string.IsNullOrWhiteSpace(npc.DisplayName))
            .Select(npc => npc.DisplayName)
            .ToList();
        if (npcNames.Count > 0)
        {
            stringFilters.Add(string.Join(",", npcNames));
        }

        // Keywords (+ separated for AND)
        var keywordEditorIds = entry.SelectedKeywords
            .Where(k => !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => k.EditorID)
            .ToList();
        if (keywordEditorIds.Count > 0)
        {
            stringFilters.Add(string.Join("+", keywordEditorIds));
        }

        var stringFiltersPart = stringFilters.Count > 0 ? string.Join(",", stringFilters) : null;

        // Position 3: FormFilters - Factions, Races, Classes (+ for AND)
        var formFilters = new List<string>();

        foreach (var faction in entry.SelectedFactions)
        {
            var editorId = faction.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        foreach (var race in entry.SelectedRaces)
        {
            var editorId = race.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        foreach (var classVm in entry.SelectedClasses)
        {
            var editorId = classVm.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        var formFiltersPart = formFilters.Count > 0 ? string.Join("+", formFilters) : null;

        // Position 4: LevelFilters (skill filters like "12(85/999)")
        var levelFiltersPart = !string.IsNullOrWhiteSpace(entry.LevelFilters) ? entry.LevelFilters : null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.Entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.UseChance && entry.Chance != 100
            ? entry.Chance.ToString(CultureInfo.InvariantCulture)
            : null;

        // Build the line, preserving intermediate NONEs but trimming trailing ones
        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        // Find the last non-null position
        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        // Build the SPID line
        var sb = new StringBuilder();
        sb.Append("Outfit = ");
        sb.Append(outfitIdentifier);

        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a single entry as a SPID keyword distribution line.
    /// Format: Keyword = EditorID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidKeywordLine(DistributionEntryViewModel entry)
    {
        if (string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
            throw new ArgumentException("Entry must have a keyword to distribute", nameof(entry));

        // Position 1: Keyword EditorID
        var keywordIdentifier = entry.KeywordToDistribute;

        // Position 2: StringFilters - NPC names (comma-separated) and Keywords (+ for AND)
        var stringFilters = new List<string>();

        var npcNames = entry.SelectedNpcs
            .Where(npc => !string.IsNullOrWhiteSpace(npc.DisplayName))
            .Select(npc => npc.DisplayName)
            .ToList();
        if (npcNames.Count > 0)
        {
            stringFilters.Add(string.Join(",", npcNames));
        }

        var keywordEditorIds = entry.SelectedKeywords
            .Where(k => !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => k.EditorID)
            .ToList();
        if (keywordEditorIds.Count > 0)
        {
            stringFilters.Add(string.Join("+", keywordEditorIds));
        }

        var stringFiltersPart = stringFilters.Count > 0 ? string.Join(",", stringFilters) : null;

        // Position 3: FormFilters - Factions, Races, Classes (+ for AND)
        var formFilters = new List<string>();

        foreach (var faction in entry.SelectedFactions)
        {
            var editorId = faction.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        foreach (var race in entry.SelectedRaces)
        {
            var editorId = race.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        foreach (var classVm in entry.SelectedClasses)
        {
            var editorId = classVm.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilters.Add(editorId);
            }
        }

        var formFiltersPart = formFilters.Count > 0 ? string.Join("+", formFilters) : null;

        // Position 4: LevelFilters (skill filters like "12(85/999)")
        var levelFiltersPart = !string.IsNullOrWhiteSpace(entry.LevelFilters) ? entry.LevelFilters : null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.Entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.UseChance && entry.Chance != 100
            ? entry.Chance.ToString(CultureInfo.InvariantCulture)
            : null;

        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        var sb = new StringBuilder();
        sb.Append("Keyword = ");
        sb.Append(keywordIdentifier);

        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a single entry as a SkyPatcher distribution line.
    /// Format: filterByX=value:filterByY=value:outfitDefault=FormKey
    /// </summary>
    public static string FormatSkyPatcherLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));

        var filterParts = new List<string>();

        if (entry.SelectedNpcs.Count > 0)
        {
            var npcFormKeys = entry.SelectedNpcs
                .Select(npc => FormKeyHelper.Format(npc.FormKey))
                .ToList();
            var npcList = string.Join(",", npcFormKeys);
            filterParts.Add($"filterByNpcs={npcList}");
        }

        if (entry.SelectedFactions.Count > 0)
        {
            var factionFormKeys = entry.SelectedFactions
                .Select(faction => FormKeyHelper.Format(faction.FormKey))
                .ToList();
            var factionList = string.Join(",", factionFormKeys);
            filterParts.Add($"filterByFactions={factionList}");
        }

        if (entry.SelectedKeywords.Count > 0)
        {
            var keywordFormKeys = entry.SelectedKeywords
                .Select(keyword => FormKeyHelper.Format(keyword.FormKey))
                .ToList();
            var keywordList = string.Join(",", keywordFormKeys);
            filterParts.Add($"filterByKeywords={keywordList}");
        }

        if (entry.SelectedRaces.Count > 0)
        {
            var raceFormKeys = entry.SelectedRaces
                .Select(race => FormKeyHelper.Format(race.FormKey))
                .ToList();
            var raceList = string.Join(",", raceFormKeys);
            filterParts.Add($"filterByRaces={raceList}");
        }

        if (entry.SelectedClasses.Count > 0)
        {
            var classFormKeys = entry.SelectedClasses
                .Select(c => FormKeyHelper.Format(c.FormKey))
                .ToList();
            var classList = string.Join(",", classFormKeys);
            filterParts.Add($"filterByClass={classList}");
        }

        if (entry.Gender != GenderFilter.Any)
        {
            var genderValue = entry.Gender == GenderFilter.Female ? "female" : "male";
            filterParts.Add($"filterByGender={genderValue}");
        }

        var outfitFormKey = FormKeyHelper.Format(entry.SelectedOutfit.FormKey);
        filterParts.Add($"outfitDefault={outfitFormKey}");

        return string.Join(":", filterParts);
    }

    /// <summary>
    /// Formats SPID trait filters (Position 5).
    /// </summary>
    public static string? FormatTraitFilters(SpidTraitFilters traits)
    {
        if (traits.IsEmpty)
            return null;

        var parts = new List<string>();

        if (traits.IsFemale == true)
            parts.Add("F");
        else if (traits.IsFemale == false)
            parts.Add("M");

        if (traits.IsUnique == true)
            parts.Add("U");
        else if (traits.IsUnique == false)
            parts.Add("-U");

        if (traits.IsSummonable == true)
            parts.Add("S");
        else if (traits.IsSummonable == false)
            parts.Add("-S");

        if (traits.IsChild == true)
            parts.Add("C");
        else if (traits.IsChild == false)
            parts.Add("-C");

        if (traits.IsLeveled == true)
            parts.Add("L");
        else if (traits.IsLeveled == false)
            parts.Add("-L");

        if (traits.IsTeammate == true)
            parts.Add("T");
        else if (traits.IsTeammate == false)
            parts.Add("-T");

        if (traits.IsDead == true)
            parts.Add("D");
        else if (traits.IsDead == false)
            parts.Add("-D");

        return parts.Count > 0 ? string.Join("/", parts) : null;
    }
}
