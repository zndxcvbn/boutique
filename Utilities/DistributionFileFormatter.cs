using System.Globalization;
using System.Reflection;
using System.Text;
using Boutique.Models;
using Boutique.ViewModels;

namespace Boutique.Utilities;

/// <summary>
///     Central formatter for distribution file content.
///     This is the single source of truth for SPID and SkyPatcher file format generation.
/// </summary>
public static class DistributionFileFormatter
{
    /// <summary>
    ///     Gets the application version from the assembly's informational version (set by MinVer from git tags).
    /// </summary>
    public static string GetAppVersion()
    {
        var assembly = Assembly.GetExecutingAssembly();
        var infoVersion = assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>()?.InformationalVersion;

        if (!string.IsNullOrEmpty(infoVersion))
        {
            var plusIndex = infoVersion.IndexOf('+');
            return plusIndex > 0 ? infoVersion[..plusIndex] : infoVersion;
        }

        var version = assembly.GetName().Version;
        return version != null ? $"{version.Major}.{version.Minor}.{version.Build}" : "0.0.0";
    }

    /// <summary>
    ///     Generates the standard header lines for distribution files.
    /// </summary>
    public static List<string> GenerateHeaderLines(string? fileTypePrefix = null)
    {
        var version = GetAppVersion();
        var date = DateTime.Now.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
        var prefix = string.IsNullOrEmpty(fileTypePrefix) ? "" : $"{fileTypePrefix} ";

        return
        [
            $"; {prefix}Distribution File",
            $"; Generated by Boutique: {version}",
            $"; Last Modified: {date}",
            string.Empty
        ];
    }

    /// <summary>
    ///     Generates the complete file content for a distribution file.
    /// </summary>
    public static string GenerateFileContent(
        IEnumerable<DistributionEntryViewModel> entries,
        DistributionFileType format,
        IReadOnlyList<DistributionParseError>? unparsedLines = null)
    {
        var lines = GenerateHeaderLines();

        foreach (var entry in entries)
        {
            string? line = null;

            if (entry.Type == DistributionType.Keyword)
            {
                if (!string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
                {
                    line = FormatSpidKeywordLine(entry);
                }
            }
            else if (entry.SelectedOutfit != null)
            {
                line = format == DistributionFileType.Spid
                    ? FormatSpidLine(entry)
                    : FormatSkyPatcherLine(entry);
            }

            if (line != null)
            {
                lines.Add(line);
            }
        }

        if (unparsedLines is not { Count: > 0 })
        {
            return string.Join(Environment.NewLine, lines);
        }

        var spidPreserved = unparsedLines.Where(e =>
            e.Reason.EndsWith("(preserved)", StringComparison.Ordinal) &&
            e.Reason.Contains("SPID", StringComparison.OrdinalIgnoreCase)).ToList();
        var skyPatcherPreserved = unparsedLines.Where(e =>
            e.Reason.EndsWith("(preserved)", StringComparison.Ordinal) &&
            e.Reason.Contains("SkyPatcher", StringComparison.OrdinalIgnoreCase)).ToList();
        var errorLines = unparsedLines.Where(e => !e.Reason.EndsWith("(preserved)", StringComparison.Ordinal)).ToList();

        if (spidPreserved.Count > 0)
        {
            lines.Add(string.Empty);
            lines.Add("; Other SPID distributions (preserved from original file)");
            lines.AddRange(spidPreserved.Select(preserved => preserved.LineContent));
        }

        if (skyPatcherPreserved.Count > 0)
        {
            lines.Add(string.Empty);
            lines.Add("; SkyPatcher distributions with unresolved filters (preserved from original file)");
            lines.AddRange(skyPatcherPreserved.Select(preserved => preserved.LineContent));
        }

        if (errorLines.Count <= 0)
        {
            return string.Join(Environment.NewLine, lines);
        }

        lines.Add(string.Empty);
        lines.Add("; Lines that Boutique could not parse (preserved from original file)");
        lines.AddRange(errorLines.Select(error => error.LineContent));

        return string.Join(Environment.NewLine, lines);
    }

    /// <summary>
    ///     Formats a single entry as a SPID distribution line.
    ///     Format: Outfit = FormID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
        {
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));
        }

        var outfitIdentifier = FormKeyHelper.FormatForSpid(entry.SelectedOutfit.FormKey);
        return BuildSpidLine("Outfit", outfitIdentifier, entry);
    }

    /// <summary>
    ///     Formats a single entry as a SPID keyword distribution line.
    ///     Format: Keyword = EditorID|StringFilters|FormFilters|LevelFilters|TraitFilters|Count|Chance
    /// </summary>
    public static string FormatSpidKeywordLine(DistributionEntryViewModel entry)
    {
        if (string.IsNullOrWhiteSpace(entry.KeywordToDistribute))
        {
            throw new ArgumentException("Entry must have a keyword to distribute", nameof(entry));
        }

        return BuildSpidLine("Keyword", entry.KeywordToDistribute, entry);
    }

    private static string BuildSpidLine(string formType, string identifier, DistributionEntryViewModel entry)
    {
        var (stringFiltersPart, formFiltersPart) = BuildSpidFilterParts(entry);
        var levelFiltersPart = !string.IsNullOrWhiteSpace(entry.LevelFilters) ? entry.LevelFilters : null;
        var traitFiltersPart = FormatTraitFilters(entry.Entry.TraitFilters);
        string? countPart = null;
        var chancePart = entry.UseChance && entry.Chance != 100
            ? entry.Chance.ToString(CultureInfo.InvariantCulture)
            : null;

        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        var lastNonNullIndex = Array.FindLastIndex(parts, p => p != null);

        var sb = new StringBuilder();
        sb.Append(formType);
        sb.Append(" = ");
        sb.Append(identifier);

        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    private static (string? StringFilters, string? FormFilters) BuildSpidFilterParts(DistributionEntryViewModel entry)
    {
        var stringFilterParts = new List<string>();

        var includedNpcNames = entry.SelectedNpcs
            .Where(npc => !npc.IsExcluded && !string.IsNullOrWhiteSpace(npc.DisplayName))
            .Select(npc => npc.DisplayName)
            .ToList();
        if (includedNpcNames.Count > 0)
        {
            stringFilterParts.Add(string.Join(",", includedNpcNames));
        }

        var includedKeywords = entry.SelectedKeywords
            .Where(k => !k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => k.EditorID)
            .ToList();
        if (includedKeywords.Count > 0)
        {
            stringFilterParts.Add(string.Join("+", includedKeywords));
        }

        var excludedKeywords = entry.SelectedKeywords
            .Where(k => k.IsExcluded && !string.IsNullOrWhiteSpace(k.EditorID) && k.EditorID != "(No EditorID)")
            .Select(k => $"-{k.EditorID}")
            .ToList();
        stringFilterParts.AddRange(excludedKeywords);

        if (!string.IsNullOrWhiteSpace(entry.RawStringFilters))
        {
            stringFilterParts.Add(entry.RawStringFilters.Trim());
        }

        var stringFiltersPart = stringFilterParts.Count > 0 ? string.Join(",", stringFilterParts) : null;

        var formFilterParts = new List<string>();
        var formExclusions = new List<string>();

        AddFormFiltersWithExclusions(entry.SelectedFactions, formFilterParts, formExclusions);
        AddFormFiltersWithExclusions(entry.SelectedRaces, formFilterParts, formExclusions);

        foreach (var classVm in entry.SelectedClasses)
        {
            var editorId = classVm.EditorID;
            if (!string.IsNullOrWhiteSpace(editorId) && editorId != "(No EditorID)")
            {
                formFilterParts.Add(editorId);
            }
        }

        foreach (var outfitVm in entry.SelectedOutfitFilters)
        {
            formFilterParts.Add(FormKeyHelper.FormatForSpid(outfitVm.FormKey));
        }

        foreach (var npc in entry.SelectedNpcs.Where(n => n.IsExcluded))
        {
            formExclusions.Add($"-{FormKeyHelper.FormatForSpid(npc.FormKey)}");
        }

        var formFilterResult = new List<string>();
        if (formFilterParts.Count > 0)
        {
            formFilterResult.Add(string.Join("+", formFilterParts));
        }

        formFilterResult.AddRange(formExclusions);

        if (!string.IsNullOrWhiteSpace(entry.RawFormFilters))
        {
            formFilterResult.Add(entry.RawFormFilters.Trim());
        }

        var formFiltersPart = formFilterResult.Count > 0 ? string.Join(",", formFilterResult) : null;

        return (stringFiltersPart, formFiltersPart);
    }

    private static void AddFormFiltersWithExclusions(
        IEnumerable<ISelectableRecordViewModel> items,
        List<string> formFilterParts,
        List<string> formExclusions)
    {
        foreach (var item in items)
        {
            var editorId = item.EditorID;
            if (string.IsNullOrWhiteSpace(editorId) || editorId == "(No EditorID)")
            {
                continue;
            }

            if (item.IsExcluded)
            {
                formExclusions.Add($"-{editorId}");
            }
            else
            {
                formFilterParts.Add(editorId);
            }
        }
    }

    /// <summary>
    ///     Formats a single entry as a SkyPatcher distribution line.
    ///     Format: filterByX=value:filterByY=value:outfitDefault=FormKey
    /// </summary>
    public static string FormatSkyPatcherLine(DistributionEntryViewModel entry)
    {
        if (entry.SelectedOutfit == null)
        {
            throw new ArgumentException("Entry must have a selected outfit", nameof(entry));
        }

        var filterParts = new List<string>();

        if (entry.SelectedNpcs.Count > 0)
        {
            var npcFormKeys = entry.SelectedNpcs
                .Select(npc => FormKeyHelper.Format(npc.FormKey))
                .ToList();
            var npcList = string.Join(",", npcFormKeys);
            filterParts.Add($"filterByNpcs={npcList}");
        }

        if (entry.SelectedFactions.Count > 0)
        {
            var factionFormKeys = entry.SelectedFactions
                .Select(faction => FormKeyHelper.Format(faction.FormKey))
                .ToList();
            var factionList = string.Join(",", factionFormKeys);
            filterParts.Add($"filterByFactions={factionList}");
        }

        if (entry.SelectedKeywords.Count > 0)
        {
            var keywordFormKeys = entry.SelectedKeywords
                .Select(keyword => FormKeyHelper.Format(keyword.FormKey))
                .ToList();
            var keywordList = string.Join(",", keywordFormKeys);
            filterParts.Add($"filterByKeywords={keywordList}");
        }

        if (entry.SelectedRaces.Count > 0)
        {
            var raceFormKeys = entry.SelectedRaces
                .Select(race => FormKeyHelper.Format(race.FormKey))
                .ToList();
            var raceList = string.Join(",", raceFormKeys);
            filterParts.Add($"filterByRaces={raceList}");
        }

        if (entry.SelectedClasses.Count > 0)
        {
            var classFormKeys = entry.SelectedClasses
                .Select(c => FormKeyHelper.Format(c.FormKey))
                .ToList();
            var classList = string.Join(",", classFormKeys);
            filterParts.Add($"filterByClass={classList}");
        }

        if (entry.Gender != GenderFilter.Any)
        {
            var genderValue = entry.Gender == GenderFilter.Female ? "female" : "male";
            filterParts.Add($"filterByGender={genderValue}");
        }

        var outfitFormKey = FormKeyHelper.Format(entry.SelectedOutfit.FormKey);
        filterParts.Add($"outfitDefault={outfitFormKey}");

        return string.Join(":", filterParts);
    }

    /// <summary>
    ///     Formats a parsed SpidDistributionFilter back to SPID syntax.
    ///     This enables round-trip testing of parsing/formatting.
    /// </summary>
    public static string FormatSpidDistributionFilter(SpidDistributionFilter filter)
    {
        var formTypeKeyword = filter.FormType switch
        {
            SpidFormType.Outfit => "Outfit",
            SpidFormType.Keyword => "Keyword",
            SpidFormType.Spell => "Spell",
            SpidFormType.Perk => "Perk",
            SpidFormType.Item => "Item",
            SpidFormType.Shout => "Shout",
            SpidFormType.Package => "Package",
            SpidFormType.Faction => "Faction",
            SpidFormType.SleepOutfit => "SleepOutfit",
            SpidFormType.Skin => "Skin",
            _ => "Outfit"
        };

        var stringFiltersPart = FormatFilterSection(filter.StringFilters);
        var formFiltersPart = FormatFilterSection(filter.FormFilters);
        var levelFiltersPart = filter.LevelFilters;
        var traitFiltersPart = FormatTraitFilters(filter.TraitFilters);
        var countPart = filter.CountOrPackageIdx;
        var chancePart = filter.Chance != 100 ? filter.Chance.ToString(CultureInfo.InvariantCulture) : null;

        var parts = new[]
        {
            stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart
        };

        // Find the last non-null value
        var lastOutputIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastOutputIndex = i;
                break;
            }
        }

        var sb = new StringBuilder();
        sb.Append(formTypeKeyword);
        sb.Append(" = ");
        sb.Append(filter.FormIdentifier);

        for (var i = 0; i <= lastOutputIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    ///     Formats a SpidFilterSection back to SPID syntax.
    ///     Uses + for AND (within expression), , for OR (between expressions), and , for global exclusions.
    /// </summary>
    public static string? FormatFilterSection(SpidFilterSection section)
    {
        if (section.IsEmpty)
        {
            return null;
        }

        var result = new List<string>();

        foreach (var expr in section.Expressions)
        {
            if (expr.Parts.Count == 0)
            {
                continue;
            }

            var parts = expr.Parts.Select(part =>
            {
                var prefix = part.IsNegated ? "-" : string.Empty;
                return $"{prefix}{part.Value}";
            });

            result.Add(string.Join("+", parts));
        }

        foreach (var exclusion in section.GlobalExclusions)
        {
            result.Add($"-{exclusion.Value}");
        }

        return result.Count > 0 ? string.Join(",", result) : null;
    }

    /// <summary>
    ///     Formats SPID trait filters (Position 5).
    /// </summary>
    public static string? FormatTraitFilters(SpidTraitFilters traits)
    {
        if (traits.IsEmpty)
        {
            return null;
        }

        var traitMappings = new (bool? value, string trueFlag, string falseFlag)[]
        {
            (traits.IsFemale, "F", "M"),
            (traits.IsUnique, "U", "-U"),
            (traits.IsSummonable, "S", "-S"),
            (traits.IsChild, "C", "-C"),
            (traits.IsLeveled, "L", "-L"),
            (traits.IsTeammate, "T", "-T"),
            (traits.IsDead, "D", "-D")
        };

        var parts = traitMappings
            .Where(m => m.value.HasValue)
            .Select(m => m.value!.Value ? m.trueFlag : m.falseFlag)
            .ToList();

        return parts.Count > 0 ? string.Join("/", parts) : null;
    }
}
