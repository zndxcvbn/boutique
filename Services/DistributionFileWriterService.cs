using System.Globalization;
using System.IO;
using System.Text;
using Boutique.Models;
using Boutique.Utilities;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Serilog;

namespace Boutique.Services;

public class DistributionFileWriterService
{
    private readonly ILogger _logger;
    private readonly MutagenService _mutagenService;

    public DistributionFileWriterService(MutagenService mutagenService, ILogger logger)
    {
        _mutagenService = mutagenService;
        _logger = logger.ForContext<DistributionFileWriterService>();
    }

    public async Task WriteDistributionFileAsync(
        string filePath,
        IReadOnlyList<DistributionEntry> entries,
        DistributionFileType format,
        CancellationToken cancellationToken = default)
    {
        await Task.Run(
            () =>
            {
                try
                {
                    var directory = Path.GetDirectoryName(filePath);
                    if (!string.IsNullOrWhiteSpace(directory) && !Directory.Exists(directory))
                    {
                        Directory.CreateDirectory(directory);
                        _logger.Information("Created directory: {Directory}", directory);
                    }

                    var lines = new List<string>();
                    var formatName = format == DistributionFileType.Spid ? "SPID" : "SkyPatcher";
                    lines.Add($"; {formatName} Distribution File");
                    lines.Add("; Generated by Boutique");
                    lines.Add(string.Empty);

                    if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
                    {
                        _logger.Warning("LinkCache not available. Cannot write distribution file.");
                        throw new InvalidOperationException("LinkCache not available.");
                    }

                    var anyEntryUsesChance = entries.Any(e => e.Chance.HasValue);
                    var effectiveFormat = anyEntryUsesChance ? DistributionFileType.Spid : format;

                    foreach (var entry in entries)
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        if (entry.Outfit == null)
                        {
                            continue;
                        }

                        if (effectiveFormat == DistributionFileType.Spid)
                        {
                            var spidLine = FormatSpidLine(entry, linkCache);
                            lines.Add(spidLine);
                        }
                        else
                        {
                            var filterParts = new List<string>();

                            var includedNpcs = entry.NpcFilters.Where(f => !f.IsExcluded).ToList();
                            var excludedNpcs = entry.NpcFilters.Where(f => f.IsExcluded).ToList();
                            if (includedNpcs.Count > 0)
                            {
                                var npcList = string.Join(",", includedNpcs.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByNpcs={npcList}");
                            }

                            if (excludedNpcs.Count > 0)
                            {
                                var npcList = string.Join(",", excludedNpcs.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByNpcsExcluded={npcList}");
                            }

                            var includedFactions = entry.FactionFilters.Where(f => !f.IsExcluded).ToList();
                            var excludedFactions = entry.FactionFilters.Where(f => f.IsExcluded).ToList();
                            if (includedFactions.Count > 0)
                            {
                                var factionList = string.Join(
                                    ",",
                                    includedFactions.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByFactions={factionList}");
                            }

                            if (excludedFactions.Count > 0)
                            {
                                var factionList = string.Join(
                                    ",",
                                    excludedFactions.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByFactionsExcluded={factionList}");
                            }

                            var includedKeywords = entry.KeywordFilters.Where(f => !f.IsExcluded).ToList();
                            var excludedKeywords = entry.KeywordFilters.Where(f => f.IsExcluded).ToList();
                            if (includedKeywords.Count > 0 && linkCache != null)
                            {
                                var keywordFormKeys = includedKeywords
                                    .Select(k => ResolveKeywordEditorIdToFormKey(k.EditorId, linkCache))
                                    .Where(fk => !fk.IsNull)
                                    .Select(FormatFormKey)
                                    .ToList();
                                if (keywordFormKeys.Count > 0)
                                {
                                    var keywordList = string.Join(",", keywordFormKeys);
                                    filterParts.Add($"filterByKeywords={keywordList}");
                                }
                            }

                            if (excludedKeywords.Count > 0 && linkCache != null)
                            {
                                var keywordFormKeys = excludedKeywords
                                    .Select(k => ResolveKeywordEditorIdToFormKey(k.EditorId, linkCache))
                                    .Where(fk => !fk.IsNull)
                                    .Select(FormatFormKey)
                                    .ToList();
                                if (keywordFormKeys.Count > 0)
                                {
                                    var keywordList = string.Join(",", keywordFormKeys);
                                    filterParts.Add($"filterByKeywordsExcluded={keywordList}");
                                }
                            }

                            var includedRaces = entry.RaceFilters.Where(f => !f.IsExcluded).ToList();
                            var excludedRaces = entry.RaceFilters.Where(f => f.IsExcluded).ToList();
                            if (includedRaces.Count > 0)
                            {
                                var raceList = string.Join(",", includedRaces.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByRaces={raceList}");
                            }

                            if (excludedRaces.Count > 0)
                            {
                                var raceList = string.Join(",", excludedRaces.Select(f => FormatFormKey(f.FormKey)));
                                filterParts.Add($"filterByRacesExcluded={raceList}");
                            }

                            if (entry.ClassFormKeys.Count > 0)
                            {
                                var classFormKeys = entry.ClassFormKeys
                                    .Select(fk => FormatFormKey(fk))
                                    .ToList();
                                var classList = string.Join(",", classFormKeys);
                                filterParts.Add($"filterByClass={classList}");
                            }

                            if (entry.TraitFilters.IsFemale.HasValue)
                            {
                                filterParts.Add(
                                    $"filterByGender={(entry.TraitFilters.IsFemale.Value ? "female" : "male")}");
                            }

                            var outfitFormKey = FormatFormKey(entry.Outfit.FormKey);
                            filterParts.Add($"outfitDefault={outfitFormKey}");

                            var line = string.Join(":", filterParts);
                            lines.Add(line);
                        }
                    }

                    File.WriteAllLines(filePath, lines, Encoding.UTF8);
                    _logger.Information(
                        "Wrote {Format} distribution file: {FilePath} with {EntryCount} entries",
                        effectiveFormat,
                        filePath,
                        entries.Count);
                }
                catch (OperationCanceledException)
                {
                    _logger.Information("Distribution file write cancelled.");
                    throw;
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "Failed to write distribution file: {FilePath}", filePath);
                    throw;
                }
            },
            cancellationToken);
    }

    public async Task<IReadOnlyList<DistributionEntry>> LoadDistributionFileAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        var (entries, _) = await LoadDistributionFileWithFormatAsync(filePath, cancellationToken);
        return entries;
    }

    public async Task<(IReadOnlyList<DistributionEntry> Entries, DistributionFileType DetectedFormat)>
        LoadDistributionFileWithFormatAsync(
            string filePath,
            CancellationToken cancellationToken = default)
    {
        var (entries, detectedFormat, _) = await LoadDistributionFileWithErrorsAsync(filePath, cancellationToken);
        return (entries, detectedFormat);
    }

    public async
        Task<(IReadOnlyList<DistributionEntry> Entries, DistributionFileType DetectedFormat,
            IReadOnlyList<DistributionParseError> ParseErrors)> LoadDistributionFileWithErrorsAsync(
            string filePath,
            CancellationToken cancellationToken = default)
    {
        return await Task.Run(
            () =>
            {
                var entries = new List<DistributionEntry>();
                var parseErrors = new List<DistributionParseError>();
                var hasSpidLines = false;
                var detectedFormat = DistributionFileType.SkyPatcher;

                if (!File.Exists(filePath))
                {
                    _logger.Warning("Distribution file does not exist: {FilePath}", filePath);
                    return (entries, detectedFormat, parseErrors);
                }

                if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
                {
                    _logger.Warning("LinkCache not available. Cannot load distribution file.");
                    return (entries, detectedFormat, parseErrors);
                }

                try
                {
                    var lines = File.ReadAllLines(filePath, Encoding.UTF8);

                    List<INpcGetter>? cachedNpcs = null;
                    List<IOutfitGetter>? cachedOutfits = null;

                    // Build outfit lookup for fast EditorID resolution
                    var outfitByEditorId = FormKeyHelper.BuildOutfitEditorIdLookup(linkCache);

                    for (var lineNumber = 0; lineNumber < lines.Length; lineNumber++)
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        var line = lines[lineNumber];
                        var trimmed = line.Trim();
                        if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith(';') || trimmed.StartsWith('#'))
                        {
                            continue;
                        }

                        DistributionEntry? entry = null;
                        string? parseFailureReason = null;

                        if (trimmed.Contains("outfitDefault=", StringComparison.OrdinalIgnoreCase))
                        {
                            var (parsedEntry, reason) = ParseDistributionLine(trimmed, linkCache, outfitByEditorId);
                            entry = parsedEntry;
                            parseFailureReason = reason;
                        }
                        else if (SpidLineParser.TryParse(trimmed, out var spidFilter) && spidFilter != null)
                        {
                            hasSpidLines = true;

                            // Process Outfit and Keyword lines as distribution entries
                            if (spidFilter.FormType == SpidFormType.Outfit)
                            {
                                cachedNpcs ??= linkCache.PriorityOrder.WinningOverrides<INpcGetter>().ToList();
                                cachedOutfits ??= linkCache.PriorityOrder.WinningOverrides<IOutfitGetter>().ToList();
                                entry = SpidFilterResolver.Resolve(
                                    spidFilter,
                                    linkCache,
                                    cachedNpcs,
                                    cachedOutfits,
                                    _logger);
                                if (entry == null)
                                {
                                    parseFailureReason = "Could not resolve outfit or filters from SPID syntax";
                                }
                            }
                            else if (spidFilter.FormType == SpidFormType.Keyword)
                            {
                                cachedNpcs ??= linkCache.PriorityOrder.WinningOverrides<INpcGetter>().ToList();
                                entry = SpidFilterResolver.ResolveKeyword(
                                    spidFilter,
                                    linkCache,
                                    cachedNpcs,
                                    null,
                                    _logger);
                                if (entry == null)
                                {
                                    parseFailureReason =
                                        "Could not resolve keyword distribution filters from SPID syntax";
                                }
                            }
                            else
                            {
                                parseErrors.Add(new DistributionParseError(
                                    lineNumber + 1,
                                    trimmed,
                                    $"{spidFilter.FormType} distribution (preserved)"));
                            }
                        }
                        else
                        {
                            parseFailureReason = "Unrecognized distribution syntax";
                        }

                        if (entry != null)
                        {
                            entries.Add(entry);
                        }
                        else if (parseFailureReason != null)
                        {
                            parseErrors.Add(new DistributionParseError(lineNumber + 1, trimmed, parseFailureReason));
                        }
                    }

                    detectedFormat = hasSpidLines ? DistributionFileType.Spid : DistributionFileType.SkyPatcher;

                    _logger.Information(
                        "Loaded {Count} distribution entries from {FilePath} (detected format: {Format}, {ErrorCount} parse errors)",
                        entries.Count,
                        filePath,
                        detectedFormat,
                        parseErrors.Count);
                }
                catch (OperationCanceledException)
                {
                    _logger.Information("Distribution file load cancelled.");
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "Failed to load distribution file: {FilePath}", filePath);
                }

                return (entries, detectedFormat, parseErrors);
            },
            cancellationToken);
    }

    private (DistributionEntry? Entry, string? Reason) ParseDistributionLine(
        string line,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache,
        IReadOnlyDictionary<string, FormKey> outfitByEditorId)
    {
        try
        {
            if (!SkyPatcherSyntax.HasFilter(line, "outfitDefault"))
            {
                return (null, null);
            }

            var npcStrings = SkyPatcherSyntax.ExtractFilterValues(line, "filterByNpcs");
            var excludedNpcStrings = SkyPatcherSyntax.ExtractFilterValues(line, "filterByNpcsExcluded");
            var factionStrings = SkyPatcherSyntax.ExtractFilterValuesWithVariants(line, "filterByFactions");
            var keywordStrings = SkyPatcherSyntax.ExtractFilterValuesWithVariants(line, "filterByKeywords");
            var raceStrings = SkyPatcherSyntax.ExtractFilterValuesWithVariants(line, "filterByRaces");
            var classStrings = SkyPatcherSyntax.ExtractFilterValues(line, "filterByClass");
            var genderFilter = SkyPatcherSyntax.ParseGenderFilter(line);

            var npcFilters = ResolveNpcIdentifiersToFilters(npcStrings, excludedNpcStrings, linkCache);
            var factionFilters = ResolveFactionIdentifiers(factionStrings, linkCache);
            var keywordFilters = ResolveKeywordIdentifiersToFilters(keywordStrings, linkCache);
            var raceFilters = ResolveRaceIdentifiers(raceStrings, linkCache);
            var classFormKeys = ResolveClassIdentifiers(classStrings, linkCache);

            var hasAnyParsedFilter = npcFilters.Count > 0 ||
                                     factionFilters.Count > 0 ||
                                     keywordFilters.Count > 0 ||
                                     raceFilters.Count > 0 ||
                                     classFormKeys.Count > 0 ||
                                     genderFilter.HasValue;

            var hasAnyFilterInLine =
                SkyPatcherSyntax.HasFilter(line, "filterByNpcs") ||
                SkyPatcherSyntax.HasAnyVariant(line, "filterByFactions") ||
                SkyPatcherSyntax.HasAnyVariant(line, "filterByKeywords") ||
                SkyPatcherSyntax.HasAnyVariant(line, "filterByRaces") ||
                SkyPatcherSyntax.HasFilter(line, "filterByClass") ||
                SkyPatcherSyntax.HasFilter(line, "filterByGender") ||
                SkyPatcherSyntax.HasFilter(line, "filterByEditorIdContains") ||
                SkyPatcherSyntax.HasFilter(line, "filterByEditorIdContainsOr") ||
                SkyPatcherSyntax.HasFilter(line, "filterByModNames") ||
                SkyPatcherSyntax.HasFilter(line, "filterByDefaultOutfits");

            if (hasAnyFilterInLine && !hasAnyParsedFilter)
            {
                _logger.Debug("Line has filters but none could be resolved - preserving unchanged: {Line}", line);
                return (null, "SkyPatcher filter distribution (preserved)");
            }

            var outfitString = SkyPatcherSyntax.ExtractFilterValue(line, "outfitDefault");
            if (string.IsNullOrWhiteSpace(outfitString))
            {
                return (null, null);
            }

            var outfitFormKey = FormKeyHelper.ResolveOutfit(outfitString, linkCache, outfitByEditorId);

            if (!outfitFormKey.HasValue)
            {
                _logger.Debug("Could not resolve outfit identifier: {Identifier}", outfitString);
                return (null, "SkyPatcher distribution (preserved)");
            }

            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey.Value, out var outfit))
            {
                _logger.Debug("Could not resolve outfit FormKey: {FormKey}", outfitFormKey.Value);
                return (null, "SkyPatcher distribution (preserved)");
            }

            return (
                new DistributionEntry
                {
                    Outfit = outfit,
                    NpcFilters = npcFilters,
                    FactionFilters = factionFilters,
                    KeywordFilters = keywordFilters,
                    RaceFilters = raceFilters,
                    ClassFormKeys = classFormKeys,
                    TraitFilters = new SpidTraitFilters { IsFemale = genderFilter }
                }, null);
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse distribution line: {Line}", line);
            return (null, "SkyPatcher distribution (preserved)");
        }
    }

    private List<FormKeyFilter> ResolveNpcIdentifiersToFilters(
        List<string> includedIdentifiers,
        List<string> excludedIdentifiers,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var results = new List<FormKeyFilter>();

        foreach (var id in includedIdentifiers)
        {
            if (TryResolveNpcIdentifier(id, linkCache) is { } formKey)
            {
                results.Add(new FormKeyFilter(formKey, false));
            }
        }

        foreach (var id in excludedIdentifiers)
        {
            if (TryResolveNpcIdentifier(id, linkCache) is { } formKey)
            {
                results.Add(new FormKeyFilter(formKey, true));
            }
        }

        return results;
    }

    private FormKey? TryResolveNpcIdentifier(string id, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        if (TryParseFormKey(id) is { } formKey)
        {
            return formKey;
        }

        var npc = linkCache.PriorityOrder.WinningOverrides<INpcGetter>()
            .FirstOrDefault(n => string.Equals(n.EditorID, id, StringComparison.OrdinalIgnoreCase)
                                 || string.Equals(n.Name?.String, id, StringComparison.OrdinalIgnoreCase));
        if (npc != null)
        {
            _logger.Debug("Resolved NPC EditorID/Name '{Id}' to {FormKey}", id, npc.FormKey);
            return npc.FormKey;
        }

        _logger.Warning("Could not resolve NPC identifier: {Id}", id);
        return null;
    }

    private List<FormKeyFilter> ResolveFactionIdentifiers(
        List<string> identifiers,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var results = new List<FormKeyFilter>();
        foreach (var id in identifiers)
        {
            if (TryParseFormKey(id) is { } formKey)
            {
                results.Add(new FormKeyFilter(formKey));
                continue;
            }

            var faction = linkCache.PriorityOrder.WinningOverrides<IFactionGetter>()
                .FirstOrDefault(f => string.Equals(f.EditorID, id, StringComparison.OrdinalIgnoreCase));
            if (faction != null)
            {
                results.Add(new FormKeyFilter(faction.FormKey));
                _logger.Debug("Resolved Faction EditorID '{Id}' to {FormKey}", id, faction.FormKey);
            }
            else
            {
                _logger.Warning("Could not resolve Faction identifier: {Id}", id);
            }
        }

        return results;
    }

    private static List<KeywordFilter> ResolveKeywordIdentifiersToFilters(
        List<string> identifiers,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var results = new List<KeywordFilter>();
        foreach (var id in identifiers)
        {
            // If it's a FormKey, resolve to EditorID
            if (TryParseFormKey(id) is { } formKey)
            {
                if (linkCache.TryResolve<IKeywordGetter>(formKey, out var keyword) &&
                    !string.IsNullOrWhiteSpace(keyword.EditorID))
                {
                    results.Add(new KeywordFilter(keyword.EditorID));
                    continue;
                }
            }

            // Otherwise, try to resolve as EditorID to validate it exists
            var resolvedKeyword = linkCache.PriorityOrder.WinningOverrides<IKeywordGetter>()
                .FirstOrDefault(k => string.Equals(k.EditorID, id, StringComparison.OrdinalIgnoreCase));
            if (resolvedKeyword != null)
            {
                results.Add(new KeywordFilter(resolvedKeyword.EditorID ?? id));
            }
            else
            {
                // Keep as-is (could be a virtual keyword)
                results.Add(new KeywordFilter(id));
            }
        }

        return results;
    }

    private static FormKey ResolveKeywordEditorIdToFormKey(string editorId, ILinkCache linkCache)
    {
        var keyword = linkCache.PriorityOrder.WinningOverrides<IKeywordGetter>()
            .FirstOrDefault(k => string.Equals(k.EditorID, editorId, StringComparison.OrdinalIgnoreCase));
        return keyword?.FormKey ?? FormKey.Null;
    }

    private List<FormKeyFilter> ResolveRaceIdentifiers(
        List<string> identifiers,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var results = new List<FormKeyFilter>();
        foreach (var id in identifiers)
        {
            if (TryParseFormKey(id) is { } formKey)
            {
                results.Add(new FormKeyFilter(formKey));
                continue;
            }

            var race = linkCache.PriorityOrder.WinningOverrides<IRaceGetter>()
                .FirstOrDefault(r => string.Equals(r.EditorID, id, StringComparison.OrdinalIgnoreCase));
            if (race != null)
            {
                results.Add(new FormKeyFilter(race.FormKey));
                _logger.Debug("Resolved Race EditorID '{Id}' to {FormKey}", id, race.FormKey);
            }
            else
            {
                _logger.Warning("Could not resolve Race identifier: {Id}", id);
            }
        }

        return results;
    }

    private List<FormKey> ResolveClassIdentifiers(
        List<string> identifiers,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var results = new List<FormKey>();
        foreach (var id in identifiers)
        {
            if (TryParseFormKey(id) is { } formKey)
            {
                results.Add(formKey);
                continue;
            }

            var cls = linkCache.PriorityOrder.WinningOverrides<IClassGetter>()
                .FirstOrDefault(c => string.Equals(c.EditorID, id, StringComparison.OrdinalIgnoreCase));
            if (cls != null)
            {
                results.Add(cls.FormKey);
                _logger.Debug("Resolved Class EditorID '{Id}' to {FormKey}", id, cls.FormKey);
            }
            else
            {
                _logger.Warning("Could not resolve Class identifier: {Id}", id);
            }
        }

        return results;
    }

    private static string FormatFormKey(FormKey formKey) => FormKeyHelper.Format(formKey);

    private static string FormatOutfitIdentifier(IOutfitGetter outfit) =>
        $"0x{outfit.FormKey.ID:X}~{outfit.FormKey.ModKey.FileName}";

    private static FormKey? TryParseFormKey(string text) =>
        FormKeyHelper.TryParse(text, out var formKey) ? formKey : null;

    private static string FormatSpidLine(DistributionEntry entry, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        var outfitIdentifier = FormatOutfitIdentifier(entry.Outfit!);

        var stringFilters = new List<string>();

        var npcNames = new List<string>();
        foreach (var filter in entry.NpcFilters.Where(f => !f.IsExcluded))
        {
            if (linkCache.TryResolve<INpcGetter>(filter.FormKey, out var npc))
            {
                var name = npc.Name?.String;
                if (!string.IsNullOrWhiteSpace(name))
                {
                    npcNames.Add(name);
                }
                else if (!string.IsNullOrWhiteSpace(npc.EditorID))
                {
                    npcNames.Add(npc.EditorID);
                }
            }
        }

        if (npcNames.Count > 0)
        {
            stringFilters.Add(string.Join(",", npcNames));
        }

        var includedKeywords = entry.KeywordFilters.Where(k => !k.IsExcluded).Select(k => k.EditorId).ToList();
        var excludedKeywords = entry.KeywordFilters.Where(k => k.IsExcluded).Select(k => $"-{k.EditorId}").ToList();
        if (includedKeywords.Count > 0)
        {
            stringFilters.Add(string.Join("+", includedKeywords));
        }

        if (excludedKeywords.Count > 0)
        {
            stringFilters.AddRange(excludedKeywords);
        }

        var stringFiltersPart = stringFilters.Count > 0 ? string.Join(",", stringFilters) : null;

        var formFilters = new List<string>();

        foreach (var filter in entry.FactionFilters)
        {
            if (linkCache.TryResolve<IFactionGetter>(filter.FormKey, out var faction) &&
                !string.IsNullOrWhiteSpace(faction.EditorID))
            {
                formFilters.Add(filter.IsExcluded ? $"-{faction.EditorID}" : faction.EditorID);
            }
        }

        foreach (var filter in entry.RaceFilters)
        {
            if (linkCache.TryResolve<IRaceGetter>(filter.FormKey, out var race) &&
                !string.IsNullOrWhiteSpace(race.EditorID))
            {
                formFilters.Add(filter.IsExcluded ? $"-{race.EditorID}" : race.EditorID);
            }
        }

        foreach (var classFormKey in entry.ClassFormKeys)
        {
            if (linkCache.TryResolve<IClassGetter>(classFormKey, out var classRecord) &&
                !string.IsNullOrWhiteSpace(classRecord.EditorID))
            {
                formFilters.Add(classRecord.EditorID);
            }
        }

        foreach (var filter in entry.NpcFilters.Where(f => f.IsExcluded))
        {
            formFilters.Add($"-{FormKeyHelper.FormatForSpid(filter.FormKey)}");
        }

        foreach (var combatStyleFormKey in entry.CombatStyleFormKeys)
        {
            if (linkCache.TryResolve<ICombatStyleGetter>(combatStyleFormKey, out var combatStyle) &&
                !string.IsNullOrWhiteSpace(combatStyle.EditorID))
            {
                formFilters.Add(combatStyle.EditorID);
            }
        }

        foreach (var outfitFilterFormKey in entry.OutfitFilterFormKeys)
        {
            if (linkCache.TryResolve<IOutfitGetter>(outfitFilterFormKey, out var outfitFilter) &&
                !string.IsNullOrWhiteSpace(outfitFilter.EditorID))
            {
                formFilters.Add(outfitFilter.EditorID);
            }
        }

        foreach (var perkFormKey in entry.PerkFormKeys)
        {
            if (linkCache.TryResolve<IPerkGetter>(perkFormKey, out var perk) &&
                !string.IsNullOrWhiteSpace(perk.EditorID))
            {
                formFilters.Add(perk.EditorID);
            }
        }

        foreach (var voiceTypeFormKey in entry.VoiceTypeFormKeys)
        {
            if (linkCache.TryResolve<IVoiceTypeGetter>(voiceTypeFormKey, out var voiceType) &&
                !string.IsNullOrWhiteSpace(voiceType.EditorID))
            {
                formFilters.Add(voiceType.EditorID);
            }
        }

        foreach (var locationFormKey in entry.LocationFormKeys)
        {
            if (linkCache.TryResolve<ILocationGetter>(locationFormKey, out var location) &&
                !string.IsNullOrWhiteSpace(location.EditorID))
            {
                formFilters.Add(location.EditorID);
            }
        }

        foreach (var formListFormKey in entry.FormListFormKeys)
        {
            if (linkCache.TryResolve<IFormListGetter>(formListFormKey, out var formList) &&
                !string.IsNullOrWhiteSpace(formList.EditorID))
            {
                formFilters.Add(formList.EditorID);
            }
        }

        var formFiltersPart = formFilters.Count > 0 ? string.Join(",", formFilters) : null;

        // Position 4: LevelFilters - Not supported yet
        string? levelFiltersPart = null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.Chance.HasValue && entry.Chance.Value != 100
            ? entry.Chance.Value.ToString(CultureInfo.InvariantCulture)
            : null;

        // Build the line, preserving intermediate NONEs but trimming trailing ones
        // We need to include all positions up to the last non-null value
        var parts = new[]
        {
            stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart
        };

        // Find the last non-null position
        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        // Build the SPID line
        var sb = new StringBuilder();
        sb.Append("Outfit = ");
        sb.Append(outfitIdentifier);

        // Add all parts up to and including the last non-null one
        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    private static string? FormatTraitFilters(SpidTraitFilters traits)
    {
        if (traits.IsEmpty)
        {
            return null;
        }

        var parts = new List<string>();

        if (traits.IsFemale == true)
        {
            parts.Add("F");
        }
        else if (traits.IsFemale == false)
        {
            parts.Add("M");
        }

        if (traits.IsUnique == true)
        {
            parts.Add("U");
        }
        else if (traits.IsUnique == false)
        {
            parts.Add("-U");
        }

        if (traits.IsSummonable == true)
        {
            parts.Add("S");
        }
        else if (traits.IsSummonable == false)
        {
            parts.Add("-S");
        }

        if (traits.IsChild == true)
        {
            parts.Add("C");
        }
        else if (traits.IsChild == false)
        {
            parts.Add("-C");
        }

        if (traits.IsLeveled == true)
        {
            parts.Add("L");
        }
        else if (traits.IsLeveled == false)
        {
            parts.Add("-L");
        }

        if (traits.IsTeammate == true)
        {
            parts.Add("T");
        }
        else if (traits.IsTeammate == false)
        {
            parts.Add("-T");
        }

        if (traits.IsDead == true)
        {
            parts.Add("D");
        }
        else if (traits.IsDead == false)
        {
            parts.Add("-D");
        }

        return parts.Count > 0 ? string.Join("/", parts) : null;
    }
}
