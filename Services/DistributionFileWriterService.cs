using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Boutique.Models;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Serilog;

namespace Boutique.Services;

public class DistributionFileWriterService : IDistributionFileWriterService
{
    private readonly IMutagenService _mutagenService;
    private readonly ILogger _logger;

    public DistributionFileWriterService(IMutagenService mutagenService, ILogger logger)
    {
        _mutagenService = mutagenService;
        _logger = logger.ForContext<DistributionFileWriterService>();
    }

    public async Task WriteDistributionFileAsync(
        string filePath,
        IReadOnlyList<DistributionEntry> entries,
        CancellationToken cancellationToken = default)
    {
        await Task.Run(() =>
        {
            try
            {
                var directory = Path.GetDirectoryName(filePath);
                if (!string.IsNullOrWhiteSpace(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    _logger.Information("Created directory: {Directory}", directory);
                }

                var lines = new List<string>();

                // Add header comment
                lines.Add("; SkyPatcher Distribution File");
                lines.Add("; Generated by Boutique");
                lines.Add("");

                if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
                {
                    _logger.Warning("LinkCache not available. Cannot write distribution file.");
                    throw new InvalidOperationException("LinkCache not available.");
                }

                foreach (var entry in entries)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    if (entry.Outfit == null || entry.NpcFormKeys.Count == 0)
                        continue;

                    var npcFormKeys = entry.NpcFormKeys
                        .Select(fk => FormatFormKey(fk))
                        .ToList();

                    var npcList = string.Join(",", npcFormKeys);
                    var outfitFormKey = FormatFormKey(entry.Outfit.FormKey);

                    var line = $"filterByNpcs={npcList}:outfitDefault={outfitFormKey}";
                    lines.Add(line);
                }

                // Write file with UTF-8 encoding
                File.WriteAllLines(filePath, lines, Encoding.UTF8);
                _logger.Information("Wrote distribution file: {FilePath} with {EntryCount} entries", filePath, entries.Count);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file write cancelled.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to write distribution file: {FilePath}", filePath);
                throw;
            }
        }, cancellationToken);
    }

    public async Task<IReadOnlyList<DistributionEntry>> LoadDistributionFileAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var entries = new List<DistributionEntry>();

            if (!File.Exists(filePath))
            {
                _logger.Warning("Distribution file does not exist: {FilePath}", filePath);
                return entries;
            }

            if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
            {
                _logger.Warning("LinkCache not available. Cannot load distribution file.");
                return entries;
            }

            try
            {
                var lines = File.ReadAllLines(filePath, Encoding.UTF8);
                
                // Pre-cache NPCs for SPID parsing (only if we have SPID lines)
                List<INpcGetter>? cachedNpcs = null;

                foreach (var line in lines)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var trimmed = line.Trim();
                    if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith(';') || trimmed.StartsWith('#'))
                        continue;

                    DistributionEntry? entry = null;

                    // Try SkyPatcher format first: filterByNpcs=ModKey|FormID,ModKey|FormID:outfitDefault=ModKey|FormID
                    if (trimmed.Contains("filterByNpcs=") && trimmed.Contains("outfitDefault="))
                    {
                        entry = ParseDistributionLine(trimmed, linkCache);
                    }
                    // Try SPID format: Outfit = 0x800~ModKey|EditorID[,EditorID,...]
                    else if (trimmed.StartsWith("Outfit", StringComparison.OrdinalIgnoreCase) && trimmed.Contains('~') && trimmed.Contains('|'))
                    {
                        // Lazy-load NPC cache only when we encounter SPID format
                        cachedNpcs ??= linkCache.PriorityOrder.WinningOverrides<INpcGetter>().ToList();
                        entry = ParseSpidLine(trimmed, linkCache, cachedNpcs);
                    }

                    if (entry != null)
                        entries.Add(entry);
                }

                _logger.Information("Loaded {Count} distribution entries from {FilePath}", entries.Count, filePath);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file load cancelled.");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to load distribution file: {FilePath}", filePath);
            }

            return entries;
        }, cancellationToken);
    }

    private DistributionEntry? ParseDistributionLine(string line, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        try
        {
            // Format: filterByNpcs=ModKey|FormID,ModKey|FormID:outfitDefault=ModKey|FormID
            var npcPartIndex = line.IndexOf("filterByNpcs=", StringComparison.OrdinalIgnoreCase);
            var outfitPartIndex = line.IndexOf("outfitDefault=", StringComparison.OrdinalIgnoreCase);

            if (npcPartIndex < 0 || outfitPartIndex < 0)
                return null;

            // Extract NPCs
            var npcStart = npcPartIndex + "filterByNpcs=".Length;
            var npcEnd = line.IndexOf(':', npcStart);
            if (npcEnd < 0)
                return null;

            var npcString = line.Substring(npcStart, npcEnd - npcStart);
            var npcFormKeys = npcString
                .Split(',')
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .Select(s => TryParseFormKey(s))
                .Where(fk => fk.HasValue)
                .Select(fk => fk!.Value)
                .ToList();

            if (npcFormKeys.Count == 0)
                return null;

            // Extract outfit
            var outfitStart = outfitPartIndex + "outfitDefault=".Length;
            var outfitString = line.Substring(outfitStart).Trim();
            var outfitFormKey = TryParseFormKey(outfitString);

            if (!outfitFormKey.HasValue)
                return null;

            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey.Value, out var outfit))
            {
                _logger.Debug("Could not resolve outfit: {FormKey}", outfitFormKey.Value);
                return null;
            }

            return new DistributionEntry
            {
                Outfit = outfit,
                NpcFormKeys = npcFormKeys
            };
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse distribution line: {Line}", line);
            return null;
        }
    }

    private static string FormatFormKey(FormKey formKey)
    {
        return $"{formKey.ModKey.FileName}|{formKey.ID:X8}";
    }

    private static FormKey? TryParseFormKey(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return null;

        var trimmed = text.Trim();
        var pipeIndex = trimmed.IndexOf('|');
        if (pipeIndex < 0)
            return null;

        var modKeyString = trimmed.Substring(0, pipeIndex).Trim();
        var formIdString = trimmed.Substring(pipeIndex + 1).Trim();

        if (!ModKey.TryFromNameAndExtension(modKeyString, out var modKey))
            return null;

        if (!uint.TryParse(formIdString, System.Globalization.NumberStyles.HexNumber, null, out var formId))
            return null;

        return new FormKey(modKey, formId);
    }

    private DistributionEntry? ParseSpidLine(string line, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache, List<INpcGetter> cachedNpcs)
    {
        try
        {
            // Format: Outfit = 0x800~ModKey|EditorID[,EditorID,...]
            // Or: Outfit = 800~ModKey|EditorID[,EditorID,...]
            
            var equalsIndex = line.IndexOf('=');
            if (equalsIndex < 0)
                return null;

            var valuePart = line.Substring(equalsIndex + 1).Trim();
            
            // Find the ~ separator between FormID and ModKey
            var tildeIndex = valuePart.IndexOf('~');
            if (tildeIndex < 0)
                return null;

            var formIdString = valuePart.Substring(0, tildeIndex).Trim();
            var rest = valuePart.Substring(tildeIndex + 1).Trim();

            // Parse FormID (can be 0x800 or 800)
            formIdString = formIdString.Replace("0x", "").Replace("0X", "");
            if (!uint.TryParse(formIdString, System.Globalization.NumberStyles.HexNumber, null, out var formId))
            {
                _logger.Debug("Failed to parse FormID: {FormIdString}", formIdString);
                return null;
            }

            // Find the | separator between ModKey and EditorIDs
            var pipeIndex = rest.IndexOf('|');
            if (pipeIndex < 0)
                return null;

            var modKeyString = rest.Substring(0, pipeIndex).Trim();
            var editorIdsString = rest.Substring(pipeIndex + 1).Trim();

            if (!ModKey.TryFromNameAndExtension(modKeyString, out var modKey))
            {
                _logger.Debug("Failed to parse ModKey: {ModKeyString}", modKeyString);
                return null;
            }

            // Create FormKey for the outfit
            var outfitFormKey = new FormKey(modKey, formId);
            
            // Resolve outfit
            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey, out var outfit))
            {
                _logger.Debug("Could not resolve outfit: {FormKey}", outfitFormKey);
                return null;
            }

            // Parse NPC identifiers (comma-separated)
            // SPID format allows both EditorID and Name (display name)
            var npcIdentifiers = editorIdsString
                .Split(',')
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            if (npcIdentifiers.Count == 0)
            {
                _logger.Debug("No NPC identifiers found in line: {Line}", line);
                return null;
            }

            // Resolve NPCs by EditorID or Name using the pre-cached list
            // Note: The ModKey in SPID format is for the outfit, not the NPCs
            // NPCs are identified by EditorID or Name and can be from any mod
            var npcFormKeys = new List<FormKey>();

            foreach (var identifier in npcIdentifiers)
            {
                // Try to find NPC by EditorID first, then by Name
                var npc = cachedNpcs.FirstOrDefault(n => 
                    string.Equals(n.EditorID, identifier, StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(n.Name?.String, identifier, StringComparison.OrdinalIgnoreCase));

                if (npc != null)
                {
                    npcFormKeys.Add(npc.FormKey);
                }
                else
                {
                    _logger.Debug("Could not resolve NPC by EditorID or Name: {Identifier}", identifier);
                }
            }

            if (npcFormKeys.Count == 0)
            {
                _logger.Debug("No NPCs could be resolved for line: {Line}", line);
                return null;
            }

            return new DistributionEntry
            {
                Outfit = outfit,
                NpcFormKeys = npcFormKeys
            };
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse SPID distribution line: {Line}", line);
            return null;
        }
    }
}

