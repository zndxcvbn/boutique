using System.IO;
using System.Text;
using Boutique.Models;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Serilog;

namespace Boutique.Services;

public class DistributionFileWriterService
{
    private readonly MutagenService _mutagenService;
    private readonly ILogger _logger;

    public DistributionFileWriterService(MutagenService mutagenService, ILogger logger)
    {
        _mutagenService = mutagenService;
        _logger = logger.ForContext<DistributionFileWriterService>();
    }

    public async Task WriteDistributionFileAsync(
        string filePath,
        IReadOnlyList<DistributionEntry> entries,
        DistributionFileType format,
        CancellationToken cancellationToken = default)
    {
        await Task.Run(() =>
        {
            try
            {
                var directory = Path.GetDirectoryName(filePath);
                if (!string.IsNullOrWhiteSpace(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    _logger.Information("Created directory: {Directory}", directory);
                }

                var lines = new List<string>();

                // Add header comment
                var formatName = format == DistributionFileType.Spid ? "SPID" : "SkyPatcher";
                lines.Add($"; {formatName} Distribution File");
                lines.Add("; Generated by Boutique");
                lines.Add("");

                if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
                {
                    _logger.Warning("LinkCache not available. Cannot write distribution file.");
                    throw new InvalidOperationException("LinkCache not available.");
                }

                // Auto-detect format: if any entry uses chance, use SPID format
                var anyEntryUsesChance = entries.Any(e => e.Chance.HasValue);
                var effectiveFormat = anyEntryUsesChance ? DistributionFileType.Spid : format;

                foreach (var entry in entries)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    if (entry.Outfit == null)
                        continue;

                    if (effectiveFormat == DistributionFileType.Spid)
                    {
                        // SPID format: Outfit = FormOrEditorID|StringFilters|FormFilters|LevelFilters|TraitFilters|CountOrPackageIdx|Chance
                        var outfitIdentifier = FormatOutfitIdentifier(entry.Outfit);

                        // StringFilters (position 2): Keywords
                        var stringFilters = new List<string>();
                        foreach (var keywordFormKey in entry.KeywordFormKeys)
                        {
                            if (linkCache.TryResolve<IKeywordGetter>(keywordFormKey, out var keyword) &&
                                !string.IsNullOrWhiteSpace(keyword.EditorID))
                            {
                                stringFilters.Add(keyword.EditorID);
                            }
                        }
                        var stringFiltersPart = stringFilters.Count > 0 ? string.Join("+", stringFilters) : "NONE";

                        // FormFilters (position 3): Factions and Races
                        var formFilters = new List<string>();
                        foreach (var factionFormKey in entry.FactionFormKeys)
                        {
                            if (linkCache.TryResolve<IFactionGetter>(factionFormKey, out var faction) &&
                                !string.IsNullOrWhiteSpace(faction.EditorID))
                            {
                                formFilters.Add(faction.EditorID);
                            }
                        }
                        foreach (var raceFormKey in entry.RaceFormKeys)
                        {
                            if (linkCache.TryResolve<IRaceGetter>(raceFormKey, out var race) &&
                                !string.IsNullOrWhiteSpace(race.EditorID))
                            {
                                formFilters.Add(race.EditorID);
                            }
                        }
                        var formFiltersPart = formFilters.Count > 0 ? string.Join("+", formFilters) : "NONE";

                        // LevelFilters (position 4): Not supported yet
                        var levelFiltersPart = "NONE";

                        // TraitFilters (position 5): Not supported yet
                        var traitFiltersPart = "NONE";

                        // CountOrPackageIdx (position 6): Not supported yet
                        var countPart = "NONE";

                        // Chance (position 7)
                        var chancePart = entry.Chance.HasValue ? entry.Chance.Value.ToString() : "100";

                        // Build SPID line
                        var spidLine = $"Outfit = {outfitIdentifier}|{stringFiltersPart}|{formFiltersPart}|{levelFiltersPart}|{traitFiltersPart}|{countPart}|{chancePart}";
                        lines.Add(spidLine);
                    }
                    else
                    {
                        // SkyPatcher format: filterByNpcs=...:filterByFactions=...:filterByKeywords=...:filterByRaces=...:outfitDefault=...
                        var filterParts = new List<string>();

                        // Add NPC filter if present
                        if (entry.NpcFormKeys.Count > 0)
                        {
                            var npcFormKeys = entry.NpcFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var npcList = string.Join(",", npcFormKeys);
                            filterParts.Add($"filterByNpcs={npcList}");
                        }

                        // Add faction filter if present
                        if (entry.FactionFormKeys.Count > 0)
                        {
                            var factionFormKeys = entry.FactionFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var factionList = string.Join(",", factionFormKeys);
                            filterParts.Add($"filterByFactions={factionList}");
                        }

                        // Add keyword filter if present
                        if (entry.KeywordFormKeys.Count > 0)
                        {
                            var keywordFormKeys = entry.KeywordFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var keywordList = string.Join(",", keywordFormKeys);
                            filterParts.Add($"filterByKeywords={keywordList}");
                        }

                        // Add race filter if present
                        if (entry.RaceFormKeys.Count > 0)
                        {
                            var raceFormKeys = entry.RaceFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var raceList = string.Join(",", raceFormKeys);
                            filterParts.Add($"filterByRaces={raceList}");
                        }

                        // Add outfit
                        var outfitFormKey = FormatFormKey(entry.Outfit.FormKey);
                        filterParts.Add($"outfitDefault={outfitFormKey}");

                        var line = string.Join(":", filterParts);
                        lines.Add(line);
                    }
                }

                // Write file with UTF-8 encoding
                File.WriteAllLines(filePath, lines, Encoding.UTF8);
                _logger.Information("Wrote {Format} distribution file: {FilePath} with {EntryCount} entries",
                    effectiveFormat, filePath, entries.Count);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file write cancelled.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to write distribution file: {FilePath}", filePath);
                throw;
            }
        }, cancellationToken);
    }

    public async Task<IReadOnlyList<DistributionEntry>> LoadDistributionFileAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        var (entries, _) = await LoadDistributionFileWithFormatAsync(filePath, cancellationToken);
        return entries;
    }

    public async Task<(IReadOnlyList<DistributionEntry> Entries, DistributionFileType DetectedFormat)> LoadDistributionFileWithFormatAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var entries = new List<DistributionEntry>();
            var hasSpidLines = false;
            DistributionFileType detectedFormat = DistributionFileType.SkyPatcher;

            if (!File.Exists(filePath))
            {
                _logger.Warning("Distribution file does not exist: {FilePath}", filePath);
                return (entries, detectedFormat);
            }

            if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
            {
                _logger.Warning("LinkCache not available. Cannot load distribution file.");
                return (entries, detectedFormat);
            }

            try
            {
                var lines = File.ReadAllLines(filePath, Encoding.UTF8);

                // Pre-cache NPCs for SPID parsing (only if we have SPID lines)
                List<INpcGetter>? cachedNpcs = null;

                foreach (var line in lines)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var trimmed = line.Trim();
                    if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith(';') || trimmed.StartsWith('#'))
                        continue;

                    DistributionEntry? entry = null;

                    // Try SkyPatcher format first: filterByNpcs=...:filterByFactions=...:outfitDefault=...
                    if (trimmed.Contains("outfitDefault=") &&
                        (trimmed.Contains("filterByNpcs=") || trimmed.Contains("filterByFactions=") ||
                         trimmed.Contains("filterByKeywords=") || trimmed.Contains("filterByRaces=")))
                    {
                        entry = ParseDistributionLine(trimmed, linkCache);
                    }
                    // Try SPID format: Outfit = 0x800~ModKey|EditorID[,EditorID,...]
                    else if (trimmed.StartsWith("Outfit", StringComparison.OrdinalIgnoreCase) && trimmed.Contains('~') && trimmed.Contains('|'))
                    {
                        hasSpidLines = true;
                        // Lazy-load NPC cache only when we encounter SPID format
                        cachedNpcs ??= linkCache.PriorityOrder.WinningOverrides<INpcGetter>().ToList();
                        entry = ParseSpidLine(trimmed, linkCache, cachedNpcs);
                    }

                    if (entry != null)
                        entries.Add(entry);
                }

                // Detect format: if we found SPID lines, use SPID; otherwise use SkyPatcher
                detectedFormat = hasSpidLines ? DistributionFileType.Spid : DistributionFileType.SkyPatcher;

                _logger.Information("Loaded {Count} distribution entries from {FilePath} (detected format: {Format})",
                    entries.Count, filePath, detectedFormat);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file load cancelled.");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to load distribution file: {FilePath}", filePath);
            }

            return (entries, detectedFormat);
        }, cancellationToken);
    }

    private DistributionEntry? ParseDistributionLine(string line, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        try
        {
            // Format: filterByNpcs=ModKey|FormID,ModKey|FormID:filterByFactions=ModKey|FormID:outfitDefault=ModKey|FormID
            var outfitPartIndex = line.IndexOf("outfitDefault=", StringComparison.OrdinalIgnoreCase);
            if (outfitPartIndex < 0)
                return null;

            var npcFormKeys = new List<FormKey>();
            var factionFormKeys = new List<FormKey>();

            // Extract NPCs if present
            var npcPartIndex = line.IndexOf("filterByNpcs=", StringComparison.OrdinalIgnoreCase);
            if (npcPartIndex >= 0)
            {
                var npcStart = npcPartIndex + "filterByNpcs=".Length;
                var npcEnd = line.IndexOf(':', npcStart);
                if (npcEnd < 0)
                    npcEnd = outfitPartIndex; // Use outfit position as end if no colon found

                var npcString = line.Substring(npcStart, npcEnd - npcStart);
                npcFormKeys = npcString
                    .Split(',')
                    .Select(s => s.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Select(s => TryParseFormKey(s))
                    .Where(fk => fk.HasValue)
                    .Select(fk => fk!.Value)
                    .ToList();
            }

            // Extract factions if present
            var factionPartIndex = line.IndexOf("filterByFactions=", StringComparison.OrdinalIgnoreCase);
            if (factionPartIndex >= 0)
            {
                var factionStart = factionPartIndex + "filterByFactions=".Length;
                var factionEnd = line.IndexOf(':', factionStart);
                if (factionEnd < 0)
                    factionEnd = outfitPartIndex; // Use outfit position as end if no colon found

                var factionString = line.Substring(factionStart, factionEnd - factionStart);
                factionFormKeys = factionString
                    .Split(',')
                    .Select(s => s.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Select(s => TryParseFormKey(s))
                    .Where(fk => fk.HasValue)
                    .Select(fk => fk!.Value)
                    .ToList();
            }

            // Must have at least NPCs or factions
            if (npcFormKeys.Count == 0 && factionFormKeys.Count == 0)
                return null;

            // Extract outfit
            var outfitStart = outfitPartIndex + "outfitDefault=".Length;
            var outfitString = line.Substring(outfitStart).Trim();
            var outfitFormKey = TryParseFormKey(outfitString);

            if (!outfitFormKey.HasValue)
                return null;

            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey.Value, out var outfit))
            {
                _logger.Debug("Could not resolve outfit: {FormKey}", outfitFormKey.Value);
                return null;
            }

            return new DistributionEntry
            {
                Outfit = outfit,
                NpcFormKeys = npcFormKeys,
                FactionFormKeys = factionFormKeys
            };
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse distribution line: {Line}", line);
            return null;
        }
    }

    private static string FormatFormKey(FormKey formKey)
    {
        return $"{formKey.ModKey.FileName}|{formKey.ID:X8}";
    }

    private static string FormatOutfitIdentifier(IOutfitGetter outfit)
    {
        // Format as FormKey: 0x800~Plugin.esp
        return $"0x{outfit.FormKey.ID:X}~{outfit.FormKey.ModKey.FileName}";
    }

    private static FormKey? TryParseFormKey(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return null;

        var trimmed = text.Trim();
        var pipeIndex = trimmed.IndexOf('|');
        if (pipeIndex < 0)
            return null;

        var modKeyString = trimmed.Substring(0, pipeIndex).Trim();
        var formIdString = trimmed.Substring(pipeIndex + 1).Trim();

        if (!ModKey.TryFromNameAndExtension(modKeyString, out var modKey))
            return null;

        if (!uint.TryParse(formIdString, System.Globalization.NumberStyles.HexNumber, null, out var formId))
            return null;

        return new FormKey(modKey, formId);
    }

    private DistributionEntry? ParseSpidLine(string line, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache, List<INpcGetter> cachedNpcs)
    {
        try
        {
            // Format: Outfit = 0x800~ModKey|EditorID[,EditorID,...]
            // Or: Outfit = 800~ModKey|EditorID[,EditorID,...]

            var equalsIndex = line.IndexOf('=');
            if (equalsIndex < 0)
                return null;

            var valuePart = line.Substring(equalsIndex + 1).Trim();

            // Find the ~ separator between FormID and ModKey
            var tildeIndex = valuePart.IndexOf('~');
            if (tildeIndex < 0)
                return null;

            var formIdString = valuePart.Substring(0, tildeIndex).Trim();
            var rest = valuePart.Substring(tildeIndex + 1).Trim();

            // Parse FormID (can be 0x800 or 800)
            formIdString = formIdString.Replace("0x", "").Replace("0X", "");
            if (!uint.TryParse(formIdString, System.Globalization.NumberStyles.HexNumber, null, out var formId))
            {
                _logger.Debug("Failed to parse FormID: {FormIdString}", formIdString);
                return null;
            }

            // Find the | separator between ModKey and EditorIDs
            var pipeIndex = rest.IndexOf('|');
            if (pipeIndex < 0)
                return null;

            var modKeyString = rest.Substring(0, pipeIndex).Trim();
            var editorIdsString = rest.Substring(pipeIndex + 1).Trim();

            if (!ModKey.TryFromNameAndExtension(modKeyString, out var modKey))
            {
                _logger.Debug("Failed to parse ModKey: {ModKeyString}", modKeyString);
                return null;
            }

            // Create FormKey for the outfit
            var outfitFormKey = new FormKey(modKey, formId);

            // Resolve outfit
            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey, out var outfit))
            {
                _logger.Debug("Could not resolve outfit: {FormKey}", outfitFormKey);
                return null;
            }

            // Parse NPC identifiers (comma-separated)
            // SPID format allows both EditorID and Name (display name)
            var npcIdentifiers = editorIdsString
                .Split(',')
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            if (npcIdentifiers.Count == 0)
            {
                _logger.Debug("No NPC identifiers found in line: {Line}", line);
                return null;
            }

            // Resolve NPCs by EditorID or Name using the pre-cached list
            // Note: The ModKey in SPID format is for the outfit, not the NPCs
            // NPCs are identified by EditorID or Name and can be from any mod
            var npcFormKeys = new List<FormKey>();

            foreach (var identifier in npcIdentifiers)
            {
                // Try to find NPC by EditorID first, then by Name
                var npc = cachedNpcs.FirstOrDefault(n =>
                    string.Equals(n.EditorID, identifier, StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(n.Name?.String, identifier, StringComparison.OrdinalIgnoreCase));

                if (npc != null)
                {
                    npcFormKeys.Add(npc.FormKey);
                }
                else
                {
                    _logger.Debug("Could not resolve NPC by EditorID or Name: {Identifier}", identifier);
                }
            }

            if (npcFormKeys.Count == 0)
            {
                _logger.Debug("No NPCs could be resolved for line: {Line}", line);
                return null;
            }

            return new DistributionEntry
            {
                Outfit = outfit,
                NpcFormKeys = npcFormKeys
            };
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse SPID distribution line: {Line}", line);
            return null;
        }
    }
}
