using System.Globalization;
using System.IO;
using System.Text;
using Boutique.Models;
using Boutique.Utilities;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Serilog;

namespace Boutique.Services;

public class DistributionFileWriterService
{
    private readonly MutagenService _mutagenService;
    private readonly ILogger _logger;

    public DistributionFileWriterService(MutagenService mutagenService, ILogger logger)
    {
        _mutagenService = mutagenService;
        _logger = logger.ForContext<DistributionFileWriterService>();
    }

    public async Task WriteDistributionFileAsync(
        string filePath,
        IReadOnlyList<DistributionEntry> entries,
        DistributionFileType format,
        CancellationToken cancellationToken = default)
    {
        await Task.Run(() =>
        {
            try
            {
                var directory = Path.GetDirectoryName(filePath);
                if (!string.IsNullOrWhiteSpace(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    _logger.Information("Created directory: {Directory}", directory);
                }

                var lines = new List<string>();

                // Add header comment
                var formatName = format == DistributionFileType.Spid ? "SPID" : "SkyPatcher";
                lines.Add($"; {formatName} Distribution File");
                lines.Add("; Generated by Boutique");
                lines.Add("");

                if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
                {
                    _logger.Warning("LinkCache not available. Cannot write distribution file.");
                    throw new InvalidOperationException("LinkCache not available.");
                }

                // Auto-detect format: if any entry uses chance, use SPID format
                var anyEntryUsesChance = entries.Any(e => e.Chance.HasValue);
                var effectiveFormat = anyEntryUsesChance ? DistributionFileType.Spid : format;

                foreach (var entry in entries)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    if (entry.Outfit == null)
                        continue;

                    if (effectiveFormat == DistributionFileType.Spid)
                    {
                        var spidLine = FormatSpidLine(entry, linkCache);
                        lines.Add(spidLine);
                    }
                    else
                    {
                        // SkyPatcher format: filterByNpcs=...:filterByFactions=...:filterByKeywords=...:filterByRaces=...:outfitDefault=...
                        var filterParts = new List<string>();

                        // Add NPC filter if present
                        if (entry.NpcFormKeys.Count > 0)
                        {
                            var npcFormKeys = entry.NpcFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var npcList = string.Join(",", npcFormKeys);
                            filterParts.Add($"filterByNpcs={npcList}");
                        }

                        // Add faction filter if present
                        if (entry.FactionFormKeys.Count > 0)
                        {
                            var factionFormKeys = entry.FactionFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var factionList = string.Join(",", factionFormKeys);
                            filterParts.Add($"filterByFactions={factionList}");
                        }

                        // Add keyword filter if present
                        if (entry.KeywordFormKeys.Count > 0)
                        {
                            var keywordFormKeys = entry.KeywordFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var keywordList = string.Join(",", keywordFormKeys);
                            filterParts.Add($"filterByKeywords={keywordList}");
                        }

                        // Add race filter if present
                        if (entry.RaceFormKeys.Count > 0)
                        {
                            var raceFormKeys = entry.RaceFormKeys
                                .Select(fk => FormatFormKey(fk))
                                .ToList();
                            var raceList = string.Join(",", raceFormKeys);
                            filterParts.Add($"filterByRaces={raceList}");
                        }

                        // Add outfit
                        var outfitFormKey = FormatFormKey(entry.Outfit.FormKey);
                        filterParts.Add($"outfitDefault={outfitFormKey}");

                        var line = string.Join(":", filterParts);
                        lines.Add(line);
                    }
                }

                // Write file with UTF-8 encoding
                File.WriteAllLines(filePath, lines, Encoding.UTF8);
                _logger.Information("Wrote {Format} distribution file: {FilePath} with {EntryCount} entries",
                    effectiveFormat, filePath, entries.Count);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file write cancelled.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to write distribution file: {FilePath}", filePath);
                throw;
            }
        }, cancellationToken);
    }

    public async Task<IReadOnlyList<DistributionEntry>> LoadDistributionFileAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        var (entries, _) = await LoadDistributionFileWithFormatAsync(filePath, cancellationToken);
        return entries;
    }

    public async Task<(IReadOnlyList<DistributionEntry> Entries, DistributionFileType DetectedFormat)> LoadDistributionFileWithFormatAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var entries = new List<DistributionEntry>();
            var hasSpidLines = false;
            DistributionFileType detectedFormat = DistributionFileType.SkyPatcher;

            if (!File.Exists(filePath))
            {
                _logger.Warning("Distribution file does not exist: {FilePath}", filePath);
                return (entries, detectedFormat);
            }

            if (_mutagenService.LinkCache is not ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
            {
                _logger.Warning("LinkCache not available. Cannot load distribution file.");
                return (entries, detectedFormat);
            }

            try
            {
                var lines = File.ReadAllLines(filePath, Encoding.UTF8);

                // Pre-cache NPCs and Outfits for SPID parsing (only if we have SPID lines)
                List<INpcGetter>? cachedNpcs = null;
                List<IOutfitGetter>? cachedOutfits = null;

                foreach (var line in lines)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var trimmed = line.Trim();
                    if (string.IsNullOrWhiteSpace(trimmed) || trimmed.StartsWith(';') || trimmed.StartsWith('#'))
                        continue;

                    DistributionEntry? entry = null;

                    // Try SkyPatcher format first: filterByNpcs=...:filterByFactions=...:outfitDefault=...
                    if (trimmed.Contains("outfitDefault=") &&
                        (trimmed.Contains("filterByNpcs=") || trimmed.Contains("filterByFactions=") ||
                         trimmed.Contains("filterByKeywords=") || trimmed.Contains("filterByRaces=")))
                    {
                        entry = ParseDistributionLine(trimmed, linkCache);
                    }
                    // Try SPID format: Outfit = FormOrEditorID|StringFilters|FormFilters|...
                    // Use SpidLineParser which handles both EditorID and FormKey formats
                    else if (SpidLineParser.TryParse(trimmed, out var spidFilter) && spidFilter != null)
                    {
                        hasSpidLines = true;
                        // Lazy-load caches only when we encounter SPID format
                        cachedNpcs ??= linkCache.PriorityOrder.WinningOverrides<INpcGetter>().ToList();
                        cachedOutfits ??= linkCache.PriorityOrder.WinningOverrides<IOutfitGetter>().ToList();
                        entry = SpidFilterResolver.Resolve(spidFilter, linkCache, cachedNpcs, cachedOutfits, _logger);
                    }

                    if (entry != null)
                        entries.Add(entry);
                }

                // Detect format: if we found SPID lines, use SPID; otherwise use SkyPatcher
                detectedFormat = hasSpidLines ? DistributionFileType.Spid : DistributionFileType.SkyPatcher;

                _logger.Information("Loaded {Count} distribution entries from {FilePath} (detected format: {Format})",
                    entries.Count, filePath, detectedFormat);
            }
            catch (OperationCanceledException)
            {
                _logger.Information("Distribution file load cancelled.");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Failed to load distribution file: {FilePath}", filePath);
            }

            return (entries, detectedFormat);
        }, cancellationToken);
    }

    private DistributionEntry? ParseDistributionLine(string line, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        try
        {
            // Format: filterByNpcs=ModKey|FormID,ModKey|FormID:filterByFactions=ModKey|FormID:outfitDefault=ModKey|FormID
            var outfitPartIndex = line.IndexOf("outfitDefault=", StringComparison.OrdinalIgnoreCase);
            if (outfitPartIndex < 0)
                return null;

            var npcFormKeys = new List<FormKey>();
            var factionFormKeys = new List<FormKey>();

            // Extract NPCs if present
            var npcPartIndex = line.IndexOf("filterByNpcs=", StringComparison.OrdinalIgnoreCase);
            if (npcPartIndex >= 0)
            {
                var npcStart = npcPartIndex + "filterByNpcs=".Length;
                var npcEnd = line.IndexOf(':', npcStart);
                if (npcEnd < 0)
                    npcEnd = outfitPartIndex; // Use outfit position as end if no colon found

                var npcString = line.Substring(npcStart, npcEnd - npcStart);
                npcFormKeys = npcString
                    .Split(',')
                    .Select(s => s.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Select(s => TryParseFormKey(s))
                    .Where(fk => fk.HasValue)
                    .Select(fk => fk!.Value)
                    .ToList();
            }

            // Extract factions if present
            var factionPartIndex = line.IndexOf("filterByFactions=", StringComparison.OrdinalIgnoreCase);
            if (factionPartIndex >= 0)
            {
                var factionStart = factionPartIndex + "filterByFactions=".Length;
                var factionEnd = line.IndexOf(':', factionStart);
                if (factionEnd < 0)
                    factionEnd = outfitPartIndex; // Use outfit position as end if no colon found

                var factionString = line.Substring(factionStart, factionEnd - factionStart);
                factionFormKeys = factionString
                    .Split(',')
                    .Select(s => s.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Select(s => TryParseFormKey(s))
                    .Where(fk => fk.HasValue)
                    .Select(fk => fk!.Value)
                    .ToList();
            }

            // Must have at least NPCs or factions
            if (npcFormKeys.Count == 0 && factionFormKeys.Count == 0)
                return null;

            // Extract outfit
            var outfitStart = outfitPartIndex + "outfitDefault=".Length;
            var outfitString = line.Substring(outfitStart).Trim();
            var outfitFormKey = TryParseFormKey(outfitString);

            if (!outfitFormKey.HasValue)
                return null;

            if (!linkCache.TryResolve<IOutfitGetter>(outfitFormKey.Value, out var outfit))
            {
                _logger.Debug("Could not resolve outfit: {FormKey}", outfitFormKey.Value);
                return null;
            }

            return new DistributionEntry
            {
                Outfit = outfit,
                NpcFormKeys = npcFormKeys,
                FactionFormKeys = factionFormKeys
            };
        }
        catch (Exception ex)
        {
            _logger.Debug(ex, "Failed to parse distribution line: {Line}", line);
            return null;
        }
    }

    private static string FormatFormKey(FormKey formKey) => $"{formKey.ModKey.FileName}|{formKey.ID:X8}";

    private static string FormatOutfitIdentifier(IOutfitGetter outfit) =>
        // Format as FormKey: 0x800~Plugin.esp
        $"0x{outfit.FormKey.ID:X}~{outfit.FormKey.ModKey.FileName}";

    private static FormKey? TryParseFormKey(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return null;

        var trimmed = text.Trim();
        var pipeIndex = trimmed.IndexOf('|');
        if (pipeIndex < 0)
            return null;

        var modKeyString = trimmed.Substring(0, pipeIndex).Trim();
        var formIdString = trimmed.Substring(pipeIndex + 1).Trim();

        if (!ModKey.TryFromNameAndExtension(modKeyString, out var modKey))
            return null;

        if (!uint.TryParse(formIdString, System.Globalization.NumberStyles.HexNumber, null, out var formId))
            return null;

        return new FormKey(modKey, formId);
    }

    /// <summary>
    /// Formats a DistributionEntry as a SPID line.
    /// SPID syntax: Outfit = FormOrEditorID|StringFilters|FormFilters|LevelFilters|TraitFilters|CountOrPackageIdx|Chance
    /// Trailing NONE/100 values can be omitted, but intermediate NONEs must be preserved.
    /// </summary>
    private static string FormatSpidLine(DistributionEntry entry, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        // Position 1: Outfit identifier
        var outfitIdentifier = FormatOutfitIdentifier(entry.Outfit!);

        // Position 2: StringFilters - Keywords (AND with +)
        var stringFilters = new List<string>();
        foreach (var keywordFormKey in entry.KeywordFormKeys)
        {
            if (linkCache.TryResolve<IKeywordGetter>(keywordFormKey, out var keyword) &&
                !string.IsNullOrWhiteSpace(keyword.EditorID))
            {
                stringFilters.Add(keyword.EditorID);
            }
        }
        var stringFiltersPart = stringFilters.Count > 0 ? string.Join("+", stringFilters) : null;

        // Position 3: FormFilters - Factions and Races (AND with +)
        var formFilters = new List<string>();
        foreach (var factionFormKey in entry.FactionFormKeys)
        {
            if (linkCache.TryResolve<IFactionGetter>(factionFormKey, out var faction) &&
                !string.IsNullOrWhiteSpace(faction.EditorID))
            {
                formFilters.Add(faction.EditorID);
            }
        }
        foreach (var raceFormKey in entry.RaceFormKeys)
        {
            if (linkCache.TryResolve<IRaceGetter>(raceFormKey, out var race) &&
                !string.IsNullOrWhiteSpace(race.EditorID))
            {
                formFilters.Add(race.EditorID);
            }
        }
        var formFiltersPart = formFilters.Count > 0 ? string.Join("+", formFilters) : null;

        // Position 4: LevelFilters - Not supported yet
        string? levelFiltersPart = null;

        // Position 5: TraitFilters
        var traitFiltersPart = FormatTraitFilters(entry.TraitFilters);

        // Position 6: CountOrPackageIdx - Not supported yet
        string? countPart = null;

        // Position 7: Chance
        var chancePart = entry.Chance.HasValue && entry.Chance.Value != 100
            ? entry.Chance.Value.ToString(CultureInfo.InvariantCulture)
            : null;

        // Build the line, preserving intermediate NONEs but trimming trailing ones
        // We need to include all positions up to the last non-null value
        var parts = new[] { stringFiltersPart, formFiltersPart, levelFiltersPart, traitFiltersPart, countPart, chancePart };

        // Find the last non-null position
        var lastNonNullIndex = -1;
        for (var i = parts.Length - 1; i >= 0; i--)
        {
            if (parts[i] != null)
            {
                lastNonNullIndex = i;
                break;
            }
        }

        // Build the SPID line
        var sb = new System.Text.StringBuilder();
        sb.Append("Outfit = ");
        sb.Append(outfitIdentifier);

        // Add all parts up to and including the last non-null one
        for (var i = 0; i <= lastNonNullIndex; i++)
        {
            sb.Append('|');
            sb.Append(parts[i] ?? "NONE");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats trait filters for SPID output.
    /// </summary>
    private static string? FormatTraitFilters(Models.SpidTraitFilters traits)
    {
        if (traits.IsEmpty)
            return null;

        var parts = new List<string>();

        if (traits.IsFemale == true)
            parts.Add("F");
        else if (traits.IsFemale == false)
            parts.Add("M");

        if (traits.IsUnique == true)
            parts.Add("U");
        else if (traits.IsUnique == false)
            parts.Add("-U");

        if (traits.IsSummonable == true)
            parts.Add("S");
        else if (traits.IsSummonable == false)
            parts.Add("-S");

        if (traits.IsChild == true)
            parts.Add("C");
        else if (traits.IsChild == false)
            parts.Add("-C");

        if (traits.IsLeveled == true)
            parts.Add("L");
        else if (traits.IsLeveled == false)
            parts.Add("-L");

        if (traits.IsTeammate == true)
            parts.Add("T");
        else if (traits.IsTeammate == false)
            parts.Add("-T");

        if (traits.IsDead == true)
            parts.Add("D");
        else if (traits.IsDead == false)
            parts.Add("-D");

        return parts.Count > 0 ? string.Join("/", parts) : null;
    }
}
